%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%                Basics: Mechanizing Simple Languages and Proofs               %
%                         Encoding Proofs by Induction                         %
%                  Relating Small-step and Big-step Semantics                  %
%                                                                              %
%                             by Nicolas Jeannerod                             %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%  First, let us define the bigstep semantics. The idea is that instead of     %
%  modifying the term step-by-step, we go directly to the value. This is also  %
%  called the natural semantics.                                               %
%                                                                              %
%                  v value                  t ↓ v                              %
%                  ——————— B-Value     ——————————————— B-Succ                  %
%                   v ↓ v              succ t ↓ succ v                         %
%                                                                              %
%     t1 ↓ true   t2 ↓ v                     t1 ↓ false   t3 ↓ v               %
%  ————————————————————————— B-IfTrue     ————————————————————————— B-IfFalse  %
%  if t1 then t2 else t3 ↓ v              if t1 then t2 else t3 ↓ v            %
%                                                                              %
%                  t ↓ z                  t ↓ succ v                           %
%               —————————— B-PredZero     —————————— B-PredSucc                %
%               pred t ↓ z                pred t ↓ v                           %
%                                                                              %
%             t ↓ z                          t ↓ succ v                        %
%         ——————————————— B-IszeroZero     ———————————————— B-IszeroSucc       %
%        iszero t ↓ true                  iszero t ↓ false                     %

LF bigstep : term -> term -> type =
   | b_value       : value V
		     -> bigstep V V
   | b_succ        : bigstep T V
		     -> bigstep (succ T) (succ V)

   | b_if_true     : bigstep T1 true -> bigstep T2 V
		     -> bigstep (if_then_else T1 T2 T3) V
   | b_if_false    : bigstep T1 false -> bigstep T3 V
		     -> bigstep (if_then_else T1 T2 T3) V

   | b_pred_zero   : bigstep T z
		     -> bigstep (pred T) z
   | b_pred_succ   : bigstep T (succ V)
		     -> bigstep (pred T) V

   | b_iszero_zero : bigstep T z
		     -> bigstep (iszero T) true
   | b_iszero_succ : bigstep T (succ V)
		     -> bigstep (iszero T) false
;



%  We didn't propagated the value hypothesis in the whole bigstep constructor  %
%  because we don't need it. Infact, we can prove the following:               %
%                                                                              %
%  If  t ↓ v  then v is a value.                                               %

rec bstep_value : [|- bigstep T V] -> [|- value V] =
/ total b (bstep_value _ _ b) /
  fn b => case b of 
  | [|- b_value V] => [|- V]
  | [|- b_if_true B1 B2] => bstep_value [|- B2]
  | [|- b_if_false B1 B3] => bstep_value [|- B3]
  | [|- b_succ B] =>
    let [|- V] = bstep_value [|- B] in
    [|- v_succ V]
  | [|- b_pred_zero B] => bstep_value [|- B]
  | [|- b_pred_succ B] =>
    let [|- v_succ V] = bstep_value [|- B] in
    [|- V]
  | [|- b_iszero_zero B] => [|- v_true]
  | [|- b_iszero_succ B] => [|- v_false]
;



%  Let us now prove the first part of what we want to prove: the bigstep       %
%  relation is included in the multi_step relation.                            %
%                                                                              %
%  If  t ↓ v  then  t →* v.                                                    %

rec bstep_to_mstep : [|- bigstep T V] -> [|- multi_step T V] =
/ total b (bstep_to_mstep _ _ b) /
  fn b =>
  case b of 
  | [|- b_value V] => [|- ms_ref]

  | [|- b_if_true B1 B2] : [|- bigstep (if_then_else _ T2 T3) _] =>
    let [|- M1] = bstep_to_mstep [|- B1] in
    let [|- M2] = bstep_to_mstep [|- B2] in
    let [|- M1'] = mstep_if_then_else [|- M1] [|- T2] [|- T3] in
    [|- ms_tr (ms_tr M1' (ms_step e_if_true)) M2]
	
  | [|- b_if_false B1 B3] : [|- bigstep (if_then_else _ T2 T3) _] =>
    let [|- M1] = bstep_to_mstep [|- B1] in
    let [|- M3] = bstep_to_mstep [|- B3] in
    let [|- M1'] = mstep_if_then_else [|- M1] [|- T2] [|- T3] in
    [|- ms_tr (ms_tr M1' (ms_step e_if_false)) M3]

  | [|- b_succ B] =>
    let [|- M] = bstep_to_mstep [|- B] in
    mstep_succ [|- M]

  | [|- b_pred_zero B] =>
    let [|- M] = bstep_to_mstep [|- B] in
    let [|- M'] = mstep_pred [|- M] in
    [|- ms_tr M' (ms_step e_pred_zero)]

  | [|- b_pred_succ B] =>
    let [|- M] = bstep_to_mstep [|- B] in
    let [|- M'] = mstep_pred [|- M] in
    let [|- v_succ V] = bstep_value [|- B] in
    [|- ms_tr M' (ms_step (e_pred_succ V))]

  | [|- b_iszero_zero B] =>
    let [|- M] = bstep_to_mstep [|- B] in
    let [|- M'] = mstep_iszero [|- M] in
    [|- ms_tr M' (ms_step e_iszero_zero)]

  | [|- b_iszero_succ B] =>
    let [|- M] = bstep_to_mstep [|- B] in
    let [|- M'] = mstep_iszero [|- M] in
    let [|- v_succ V] = bstep_value [|- B] in
    [|- ms_tr M' (ms_step (e_iszero_succ V))]
;



LF equal : term -> term -> type =
   | eq : equal V V
;



%  The fact that values can't change isn't trivial for Beluga, and we will     %
%  to show it. This comes from the fact that you can have different ways to    %
%  prove that `succ V` with V a value evaluates to `succ V`:                   %
%                                                                              %
%             —————————— V-True                 —————————— V-True              %
%             true value                        true value                     %
%           ——————————————— V-Succ              ——————————— B-Value            %
%           succ true value                     true ↓ true                    %
%        ————————————————————— B-Value     ————————————————————— B-Succ        %
%        succ true ↓ succ true             succ true ↓ succ true               %

rec bstep_values_stagnate : [|- bigstep V1 V2] -> [|- value V1] -> [|- equal V1 V2] =
/ total v (bstep_values_stagnate _ _ _ v) /
  fn b => fn v => case v of 
  | [|- v_zero] => let [|- b_value _] = b in [|- eq]
  | [|- v_true] => let [|- b_value _] = b in [|- eq]
  | [|- v_false] => let [|- b_value _] = b in [|- eq]
  | [|- v_succ V'] =>
    (case b of 
     | [|- b_value _] => [|- eq]
     | [|- b_succ B'] =>
       let [|- eq] = bstep_values_stagnate [|- B'] [|- V'] in [|- eq]
    )
;



%  Let us now show that if  t → t' ↓ v,  then  t ↓ v.  Once we will have       %
%  this propertie, it will not be hard to obtain the same one for →* and to    %
%  apply it to any value.                                                      %

rec step_bstep_to_bstep : [|- step T T'] -> [|- bigstep T' V] -> [|- bigstep T V] =
/ total s (step_bstep_to_bstep _ _ _ s _) /
  fn s => fn b =>
  let [|- B] = b in
  case s of 

  | [|- e_if_true] =>
    [|- b_if_true (b_value v_true) B]

  | [|- e_if_false] =>
    [|- b_if_false (b_value v_false) B]

  | [|- e_pred_zero] =>
    let [|- eq] = bstep_values_stagnate [|- B] [|- v_zero] in
    % or let [|- b_value v_zero] = [|- B] in
    [|- b_pred_zero B]

  | [|- e_pred_succ V] =>
    let [|- eq] = bstep_values_stagnate [|- B] [|- V] in
    % /!\ No `or` this time.
    % This is for this case that we wrote bstep_values_stagnate.
    [|- b_pred_succ (b_value (v_succ V))]

  | [|- e_iszero_zero] =>
    let [|- eq] = bstep_values_stagnate [|- B] [|- v_true] in
    % or let [|- b_value v_true] = [|- B] in
    [|- b_iszero_zero (b_value v_zero)]

  | [|- e_iszero_succ V] =>
    let [|- eq] = bstep_values_stagnate [|- B] [|- v_false] in
    % or let [|- b_value v_false] = [|- B] in
    [|- b_iszero_succ (b_value (v_succ V))]

  | [|- e_if_then_else S] =>
    (case [ |- B] of 
     | [|- b_value V] => impossible [|- V]
     | [|- b_if_true B1' B2'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_if_true B1 B2']
     | [|- b_if_false B1' B3'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_if_false B1 B3']
    )

  | [|- e_succ S] =>
    (case [|- B] of 
     | [|- b_value V] =>
       let [|- v_succ V'] = [|- V] in
       let [|- B'] = step_bstep_to_bstep [|- S] [|- b_value V'] in
       [|- b_succ B']
     | [|- b_succ B] =>
       let [|- B'] = step_bstep_to_bstep [|- S] [|- B] in
       [|- b_succ B']
    )

  | [|- e_pred S] =>
    (case [|- B] of 
     | [|- b_value V] => impossible [|- V]
     | [|- b_pred_zero B1'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_pred_zero B1]
     | [|- b_pred_succ B1'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_pred_succ B1]
    )

  | [|- e_iszero S] =>
    (case [|- B] of 
     | [|- b_value V] => impossible [|- V]
     | [|- b_iszero_zero B1'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_iszero_zero B1]
     | [|- b_iszero_succ B1'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_iszero_succ B1]
)
;



%  We can now easely extend this to the multi_step relation.This will just be  %
%  a simple induction on the multi_step constructor.                           %
%                                                                              %
%  If  t →* t' ↓ v  then  t ↓ v.                                               %

rec mstep_bstep_to_bstep : [|- multi_step T T'] -> [|- bigstep T' V] -> [|- bigstep T V] =
/ total s (mstep_bstep_to_bstep _ _ _ s _) /
  fn s => fn b => case s of 
  | [|- ms_tr S1 S2] =>
    let [|- B2] = mstep_bstep_to_bstep [|- S2] b in
    mstep_bstep_to_bstep [|- S1] [|- B2]
  | [|- ms_ref ] => b
  | [|- ms_step S'] => step_bstep_to_bstep [|- S'] b
;



%  And now we can prove the wanted theorem. This is only an application of     %
%  the previous one, with  t' == v.                                            %
%                                                                              %
%  If t →* v with v a value, then t ↓ v.                                       %

rec mstep_to_bstep : [|- multi_step T V] -> [|- value V] -> [|- bigstep T V] =
/ total s (mstep_to_bstep _ _ s _) /
  fn s => fn v =>
  let [|- V] = v in
  mstep_bstep_to_bstep s [|- b_value V]
;
