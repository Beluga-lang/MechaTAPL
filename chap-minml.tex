

\chapter{Encoding a Simple Language with Arithmetic and Booleans}
\label{chap:basic}
\begin{quote}
``A language that doesn't affect the way you think about programming, is
not worth knowing.''
\hfill - Alan Perlis
\end{quote}

We beging our gentle introduction to mechanizing languages and proofs by
considering a simple language with arithmetic and boolean
expressions. In general, definitions of programming languages
typically cover three fundamental aspects:
the grammar  of the language,  i.e. what are syntactically  well-formed terms in
the language,  its operational semantics,  i.e. how do we execute and evaluate a
given term,  and its  type structure, i.e. what are  well-typed expressions.  We
revisit  these concepts  for  a small language  containing booleans  and numbers
following \citep[Ch 3,Ch 8]{TAPL} in  preparation for representing this language
together with its operational semantics and type system in \beluga.

\section{Terms}\label{sec:terms-basic}
Let  us  consider  a simple language  containing booleans,  if-expressions,  and
numbers together  with simple operations  that allow us  to test whether a given
number is zero (see \cite[Ch 3, Fig 3-1,Fig 3-2]{TAPL}). We define numbers using
$\tmzero$ and $\tmsucc$-operation.  To analyze  and manipulate numbers,  we also
provide a $\tmpred$-operator.

\[
\begin{array}{ll@{\bnfas}l}
\mbox{Terms} & M & \tmfalse \bnfalt \tmtrue \bnfalt \tmif{M_1}{M_2}{M_3} \bnfalt
\tmzero \bnfalt \tmsucc M \bnfalt \tmpred M \bnfalt \tmiszero M
\end{array}
\]

The first question  we investigate is  how to define  and represent terms in the
proof  environment  \beluga. To represent  terms  in \beluga,  we declare  a type
\lstinline!term!  for  terms   together  with  constants  corresponding  to  the
constructors    $\tmfalse$,   $\tmtrue$,    $\tmzero$,   $\tmsucc$,   $\tmpred$,
$\tmiszero$,  etc.   More   precisely   we   use   the   logical   framework  LF
\citep{Harper93jacm} for introducing new types such as \lstinline!term! together
with constants  \lstinline!true!,  \lstinline!false!, etc.  that  can be used to
construct terms. All constants are used as prefix operators by default.

\begin{lstlisting}
LF term : type =
| true         : term
| false        : term
| if_then_else : term -> term -> term -> term
| z            : term
| succ         : term -> term
| pred         : term -> term
| iszero       : term -> term
;
\end{lstlisting}

To illustrate consider a few examples. We write in sanserif font what
we would write on paper and use type writer font for its equivalent
representation in \beluga.

\begin{center}
\begin{tabular}{l@{\quad is represented as \quad}l}
%\multicolumn{1}{c}{On paper} & & \multicolumn{1}{c}{Code}\\[0.5em]
$\tmif \tmfalse \tmzero {\tmsucc \tmzero}$ &
\lstinline!if_then_else false z (succ z)!\\
$\tmiszero (\tmpred (\tmsucc \tmzero))$ & \lstinline!iszero (pred (succ z))!.
\end{tabular}
\end{center}

% We can declare infix
% operator by using the keyword \lstinline!%infix!.

\section{Semantics}
Next, we define how to evaluate and execute a given term. Following
\cite{TAPL}, we define  a small-step semantics  for our  little language. To give  a  deterministic evaluation
strategy,  it is convenient to first define the values of our language.  In
\cite{TAPL}, we distinguished between terms and values in the grammar itself and
we think of values  as a sub-class of terms; moreover, we further
distinguish between numerical values and boolean values. Here we take  a slightly different
approach and define explicitly  what it means  to be a value using the judgment
$M \Value$.  We can think of these judgments  as predicates on
terms which are defined  {\em via}  axioms and inference rules.  A term $M$ is a
a value iff we can give a derivation for $M \Value$. We also do not further
distinguish between numerical values and  booleans. Although this can
be done, such a distinction makes many of the theoretical properties
needlessly more complex.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$V \Value$}: \mbox{Expression $V$ is a value}}\\[1em]
\infer[\VZero]{\tmzero \Value}{} \quad
\infer[\VSucc]{(\tmsucc V) \Value}{V \Value} \quad
\infer[\VTrue]{\tmtrue \Value}{} \quad
\infer[\VFalse]{\tmfalse \Value}{}
\end{array}
\]

Here, we identify $\tmzero$ as a value; in addition, $\tmsucc V$ is a value
provided that $V$ is a value. We also identify $\tmtrue$ and $\tmfalse$ as
values, and say that every numeric value is a value.

We are now ready to define when a term $M$ steps to another term $N$ using the
judgment $M \Steps N$ using congruence rules and reduction rules.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$M \Steps N$}: \mbox{Term $M$ steps to term $N$}}
\\[1em]
\multicolumn{1}{l}{\mbox{\text{Congruence Rules}}}
\\[1em]
\infera{\ESucc}{\tmsucc M \Steps \tmsucc N}{M \Steps N}\qquad
\infera{\EPred}{\tmpred M \Steps \tmpred N}{M \Steps N}
\\[1em]
\multicolumn{1}{c}{\infera{\EIszero}{\tmiszero M \Steps \tmiszero N}{M \Steps N}}
\\[1em]
\multicolumn{1}{c}{\infera{\EIf}{\tmif{M_1}{M_2}{M_3} \Steps \tmif{M_1'}{M_2}{M_3}}{M_1 \Steps M_1'}}
\\[1em]
\multicolumn{1}{l}{\mbox{\text{Reduction Rules (Axioms)}}}
\\[1em]
\infera{\EPredZero}{\tmpred \tmzero \Steps \tmzero}{}\qquad
\infera{\EPredSucc}{\tmpred (\tmsucc V) \Steps V}{V \Value}
\\[1em]
\infera{\EIszeroZero}{\tmiszero \tmzero \Steps \tmtrue}{} \qquad
\infera{\EIszeroSucc}{\tmiszero (\tmsucc V) \Steps \tmfalse}{V \Value}
\\[1em]
\multicolumn{1}{c}{\infera{\EIfTrue }{\tmif{\tmtrue }{M_2}{M_3} \Steps M_2}{}}
\\[1em]
\multicolumn{1}{c}{\infera{\EIfFalse}{\tmif{\tmfalse}{M_2}{M_3} \Steps M_3}{}}
\end{array}
\]

Our goal is to represent the relation $M \Steps N$ and describe the derivation
trees which correspond to evaluating a given sub-term. To accomplish this we
also must be able to construct derivation trees that prove that a given term is
a value. Recall that a data-type provides us with a definition of constructing
elements. Clearly, terms are inductively defined and are easily translated into
a data-type definition. However, we also defined inductively what it means for a
term to be a value:  we use the  axioms $\VZero$, $\VTrue$,
$\VFalse$ together with the inference rule $\VSucc$. Similarly, we defined
inductively what it means for a term $M$ to step to a term $N$.
\todo{Do we really keep data-type in the explanation? -nj}

In \beluga, data-types are powerful enough to encode such definitions about
predicates and relations. To represent the judgment $V \Value$ we define a
predicate (type family) \lstinline!value! and state that it takes terms as
argument by declaring its type as \lstinline!term -> type!. Then each rule
corresponds to a constructor in our data-type definition. A derivation tree then
corresponds to an expression formed by these constructors.

\begin{lstlisting}
LF value : term -> type =
| v_zero     : value z
| v_succ     : value V -> value (succ V)
| v_true     : value true
| v_false    : value false
;
\end{lstlisting}

In our definition of the constructor \lstinline!v_succ!, the capital letter
\lstinline!V! describes values and is thought to be universally quantified at
the outside. We can hence read the constructor \lstinline!v_succ! as follows:

\begin{center}
\begin{tabular}{p{12cm}}
``For all term \lstinline$V$, if \lstinline!D! is a derivation for
\lstinline!value V!, then we can form a derivation \lstinline!(v_succ <<V>> D)!
for \lstinline!value (succ V)!.''
\end{tabular}
\end{center}

We mark here the term \lstinline!<<V>>! in green since in practice programmers
can omit writing it and \beluga will infer it. The recipe is ``if we do not
explicitly quantify over variables in the definition of a constructor, we do not
need to pass instantiations  for them when constructing objects  using the said
constructor.''\index{Type reconstruction}\index{Implicit Arguments}

To illustrate consider the following concrete example of proving that
$\tmsucc (\tmsucc \tmzero)$ is a value and constructing a derivation
for $\tmsucc (\tmsucc \tmzero) \Value$.
\begin{center}
  \[
     \infera{\VSucc} { (\tmsucc (\tmsucc \tmzero)) \Value }
   { \infera{\VSucc} { (\tmsucc \tmzero) \Value }
   { \infera{\VZero} { \tmzero \Value } {} } }
 \]
 is represented as
 \small{\lstinline!(v_succ <<(succ z)>> (v_succ <<z>> v_zero))!}
\end{center}
\index{Encoding derivation trees}

In \beluga, we bind the derivation to the name \lstinline!v! by writing
\begin{lstlisting}
let v : [|- value (succ (succ z))] = [|- v_succ (v_succ v_zero)];
\end{lstlisting}
Note,  we write derivations using \lstinline!|-!.  On the left hand
side  of this symbol  we can list assumptions and the right hand side
describes  what we claim can be derived from these assumptions.  For example, we might say:

\begin{lstlisting}
let w : [x: term, v: value x |- value (succ (succ x))] =
        [x: term, v: value x |- v_succ (v_succ v)];
\end{lstlisting}

The right hand side can be read as: Assuming \lstinline!x: term! and
\lstinline!v: value x!, i.e. \lstinline!v! is the derivation that states that
\lstinline!x! is a value, then \lstinline!v_succ (v_succ v)! is the witness for
the fact that \lstinline!succ (succ x)! is a value. On paper we usually omit
$\vdash$, if there are no assumptions, i.e. the objects or derivations we
describe are closed.

We can similarly encode the small-step relation $M \Steps N$  between the terms
$M$ and $N$ using the type family/relation \lstinline!step!.

\begin{lstlisting}
LF step: term -> term -> type =
| e_if_true      : step (if_then_else true M2 M3) M2
| e_if_false     : step (if_then_else false M2 M3) M3
| e_pred_zero    : step (pred z) z
| e_pred_succ    : value V
                   -> step (pred (succ V)) V
| e_iszero_zero  : step (iszero z) true
| e_iszero_succ  : value V
                   -> step (iszero (succ V)) false
| e_if_then_else : step M1 M1'
                   -> step (if_then_else M1 M2 M3) (if_then_else M1' M2 M3)
| e_succ         : step M N
                   -> step (succ M) (succ N)
| e_pred         : step M N
                   -> step (pred M) (pred N)
| e_iszero       : step M N
                   -> step (iszero M) (iszero N)
;
\end{lstlisting}

Next, we show a few examples of how to encode and represent derivations that a
concrete term steps to another.

\begin{lstlisting}
let e1 : [|- step (pred (succ (pred z))) (pred (succ z))] =
         [|- e_pred (e_succ e_pred_zero)] ;

let e2 : [|- step (pred (succ z)) z] = [|- e_pred_succ v_zero] ;
\end{lstlisting}

Here \lstinline!e1! stands for the derivation

\[
\begin{array}{c}
\infer[\EPred]{(\tmpred {(\tmsucc {(\tmpred {\tmzero})})}) \Steps (\tmpred {(\tmsucc {\tmzero})})}
{\infer[\ESucc]{(\tmsucc {(\tmpred {\tmzero})}) \Steps (\tmsucc {\tmzero} )}
 {\infer[\EPredZ]{(\tmpred {\tmzero}) \Steps \tmzero}{}}
}
\end{array}
\]

The name \lstinline!e2! stands for the derivation consisting of only
the rule $\EPredSucc$.

\section{Typing}\label{sec:types-basic}

Types allow us to approximate the runtime behaviour of programs. Types classify
expressions according to their values, i.e. the value they compute. In our
simple language with arithmetic and boolean expressions, we have only two types,
namely $\Bool$ and $\Nat$, corresponding to the two kinds of values.

\[
\begin{array}{lll}
\mbox{Types} & T \bnfas & \Bool \mid \Nat
\end{array}
\]

We encode these types in \beluga using the LF type \lstinline!tp! together with
two constants \lstinline!bool! and \lstinline!nat!.

\begin{lstlisting}
LF tp : type =
| bool : tp
| nat : tp
;
\end{lstlisting}

Typing rules relate terms to types and are described by the typing judgment
$M : T$. We recall here simply the typing rules from \cite{TAPL}.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$M \hastype T$}: \mbox{Term $M$ has type $T$}}
\\[1em]
\infera{\TTrue} {\tmtrue  \hastype \Bool}{} \qquad
\infera{\TFalse}{\tmfalse \hastype \Bool}{} \qquad
\infera{\TZero}{\tmzero \hastype \Nat}{}
\\[1em]
\inferaaa{\TIf}{\tmif{M_1}{M_2}{M_3} \hastype T}{M_1 \hastype \Bool}{M_2 \hastype T}{M_3 \hastype T}
\\[1em]
\infera{\TSucc}{\tmsucc M \hastype \Nat}{M \hastype \Nat} \qquad
\infera{\TPred}{\tmpred M \hastype \Nat}{M \hastype \Nat} \qquad
\infera{\TIsZero}{\tmiszero M \hastype \Bool}{M \hastype \Nat}
\end{array}
\]


The typing relation between terms and types is encoded in \beluga using a
predicate (type family) \lstinline!hastype! which is declared with
\lstinline!term -> tp -> type!. Each typing rule corresponds to a constructor in
our data-type definition.

\begin{lstlisting}
LF hastype : term -> tp -> type =
| t_true   : hastype true bool
| t_false  : hastype false bool
| t_zero   : hastype z nat

| t_if     : hastype M1 bool -> hastype M2 T -> hastype M3 T
             -> hastype (if_then_else M1 M2 M3) T

| t_succ   : hastype M nat
             -> hastype (succ M) nat
| t_pred   : hastype M nat
             -> hastype (pred M) nat
| t_iszero : hastype M nat
             -> hastype (iszero M) bool
;
\end{lstlisting}

\chapter{Encoding Proofs by Induction}\label{chap:proofs-basic}

We now discuss some standard properties about languages which are also discussed
in \cite{TAPL} and show how we can represent such proofs as total functions that
manipulate and analyze derivation trees. In particular, we illustrate:

\begin{itemize}
\item How to represent inductive proofs about derivations
  \index{Inductive proofs about derivations} as total functions.
\item How to prove that a case is impossible.
\item How to state a property universally about terms and reason by induction on
  terms (rather than derivations).
\end{itemize}

We develop each example step-wise using the interactive programming features in
\beluga.

\section{Type preservation}

The first property we re-visit is type preservation. In particular, we write
$M : T$ and $M \Steps N$ to clearly state that we only consider closed terms.
We label here derivations with $\D$ and $\S$ writing $\proofderiv{\D}{M : T}$
and $\proofderiv{\S}{M \Steps N}$ respectively.

\begin{theorem}
  If $\proofderiv{\D}{M : T}$ and $\proofderiv{\S}{M \Steps N}$ then $N : T$.
\end{theorem}
\begin{proof}
  By structural induction on the derivation $\proofderiv{\S}{M \Steps N}$. We
  consider here only a few cases.

  \begin{case}{$\S = \infera{\EPredZero}{\tmpred \tmzero \Steps \tmzero}{}$}
    $\proofderiv{\D~}{\tmpred {\tmzero} : T}$ \hfill by assumption\\
    $\proofderiv{\D'}{\tmzero : \Nat}$ \quad and \quad $T = \Nat$ \hfill by inversion using rule $\TPred$ \\
    $\proofderiv{~~~~}{\tmzero : \Nat}$ \hfill by rule $\TZero$.
  \end{case}
  
  \begin{case}{$\S = \infera{\EPred}{\tmpred M \Steps \tmpred N}{\above{\S '}{M \Steps N}}$}
    $\proofderiv{\D~}{\tmpred M : T}$ \hfill by assumption \\
    $\proofderiv{\D'}{M : \Nat}$ \quad and \quad $T = \Nat$ \hfill by inversion using rule $\TPred$ \\
    $\proofderiv{\F~}{N : \Nat}$ \hfill by IH using $\D'$ and $\S'$\\
    $\proofderiv{~~~~}{\tmpred N : \Nat}$ \hfill by rule $\TPred$.
  \end{case}
\end{proof}


An inductive proof as the one here can be interpreted as recursive function
where case-analysis in the proof corresponds to case analysis in the program and
the appeal to the IH corresponds to making a recursive call. We also note that
we wrote $M : T$ (or $M \Steps N$ resp.), but to emphasize that both the typing
derivation and the stepping derivation are closed and do not depend on any
assumptions we write $\vdash M : T$ and $\vdash M \Steps N$ respectively. This
will scale as we generalize our language in Chapter \ref{chap:binders} to
include also variables, functions, recursion, and other constructs
variable-binding constructs.

From a program point of view, we can read the type preservation theorem as:
Given a typing derivation $\vdash M : T$ and a derivation for
$\vdash M \Steps N$, we return a typing derivation $\vdash N : T$.

We begin by translating and representing the actual theorem statement
in \beluga. This is straightforward keeping in mind that

\begin{center}
\begin{tabular}{l|l}
On paper judgment~~ & ~~Type in \beluga \\
\hline
$\vdash M : T$      & \lstinline![|- hastype M T]! \\
$\vdash M \Steps N$ & \lstinline![|- steps M N]! \\
\end{tabular}
\end{center}

\begin{lstlisting}
rec tps: [|- hastype M T] -> [|- step M N] -> [|- hastype N T] = ? ;
\end{lstlisting}

Note that \lstinline!->! is overloaded. We have used it so far in defining the
type families \lstinline!hastype!, \lstinline!step!, \lstinline!value!, and the
type \lstinline!term!. The arrow in these data-type definitions corresponded to
the line we draw, when we draw an inference rule to distinguish between the
premises and the conclusions. We merely were using the arrow to define syntactic
structures.

\todo{Continue cleaning and rewriting $t \to M$ from here.}

In \beluga, we strictly separate between the objects we are
constructing (such as derivation trees, terms, etc.) from proofs about
them. The type preservation statement \emph{makes a claim about the type of
the term we obtain when taking a single step}. In the type of the function \lstinline!tps! the
function type \lstinline!->! is much stronger; it for example allows us to write
recursive functions which analyze objects of type \lstinline![|-hastype M T]! and
\lstinline![|-step M M']! by pattern matching.

Last, we wrote \lstinline!?!. This is very useful when developing and
debugging proofs/programs, since it allows us to describe incomplete
proofs/programs and \beluga will print back to you the assumptions at
that given point and the goal which needs to be proven.
Let's fill in some of the details.

\paragraph{Introducing assumptions - Writing functions} Since we are proving an
implication, we introduce two assumptions \lstinline!d:[|-hastype M T]! and
\lstinline!s:[|-step M M']! and try to establish
\lstinline![|-hastype M' T]!. From a programmer's point of view, we need
to build a function that when given \lstinline!d:[|-hastype M T]! and
\lstinline!s:[|-step M M']! returns a derivation of type
\lstinline![|-hastype M' T]!. We use a concrete syntax similar to
ML-like languages writing

\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] = ? ;
fn d => fn s = ? ;
\end{lstlisting}


\paragraph{Case analysis - Pattern matching} Next, we split the proof
into different cases analyzing $\proofderiv{\S}{t \Steps t'}$. This corresponds
to pattern matching on \lstinline!s:[|-step M M']! in our program.

\begin{lstlisting}
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       => ?
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         => ?
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}

\index{Underscore}
We sometimes use \lstinline!_! (underscore) for an argument, if we do
not need a name for it, since it does not play a role in the
proof. For example, when representing
$\S =
\ianc{v \Value}{\tmpred ({\tmsucc v}) \Steps v}{\EPredSucc}$ we simply
write \lstinline![|-e_pred_suc _]! since the sub-derivation
representing $v \Value$ is not used in proving that types are preserved.
\\[1em]
\emph{Convention:} Variables describing sub-derivations,
i.e. variables occurring inside \lstinline![  ]! must be
upper-case. Variables describing proper assumptions in the proof,
i.e. variables introduced by \lstinline!fn!-abstraction, must be lower
case.

\paragraph{Proving - Programming} Let us now implement the two cases
in the type preservation proof we discussed earlier. We start with the
case \lstinline![e_pred_zero]! which corresponds to the base case in
our proof. Pattern matching in \lstinline!s! has not only generated
all the cases, but more importantly it has refined what \lstinline!M! and \lstinline!M'!
stand for. In this particular case, \lstinline!M = (pred z)! and
\lstinline!M' = z!. As a first step in the proof, we analyzed the assumption
\lstinline!d:[|-hastype (pred z) T]! further. We case-analyzed this
assumption and we stated ``by inversion on $\TPred$'' which indicated
that there was exactly one case.

While we can write another case-expression analyzing
\lstinline!d! in the proof, \beluga provides syntactic sugar for
case-expressions with one case; instead of writing

\noindent
\lstinline!case d of [ |-t_pred D'] => ? ! we simply write
\lstinline!let [ |-t_pred D'] = e in ?!.

\noindent
We now have learned that \lstinline!T = nat!.

\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] =
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       =>
  let [|-t_pred _ ] = d in ?
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         => ?
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}

\beluga will compile this partial program and print for the hole

\begin{lstlisting}
________________________________________________________________________________
- Meta-Context: .
________________________________________________________________________________
- Context:
tps: [ |-hastype M T] -> [ |-step M M'] -> [ |-hastype M' T]
d: [ |-hastype (pred z) nat]
s: [ |-step (pred z) z]

================================================================================
 - Goal Type: [ |-hastype z nat]

\end{lstlisting}



We now need to build an object that has type
\lstinline![ |-hastype z nat]!. This can simply be achieved by
providing
\lstinline![ |-t_zero]!.


For the step case where we are considering the case
\lstinline![ |-e_pred S']!, we also proceeded by analyzing
\lstinline!d:[ |-hastype (pred N) T]! by pattern matching. There is
only one constructor that could have been used to build \lstinline!d!
and we hence know that it must be of the form
\lstinline![ |-t_pred D']! where \lstinline!D'! stands for a
derivation
\lstinline![ |-hastype N nat]! and we learn that \lstinline!T=nat!.

We then appeal to the induction hypothesis in the proof
using \lstinline!S! and \lstinline!D'!. This corresponds to making a
recursive call \lstinline!tps [|-D'] [|-S']! and we name the resulting
derivation \lstinline![|-F]!. Finally, we construct our derivation
\lstinline![ |-t_pred F]! for \lstinline![ |-hastype (pred N') nat]!.

\begin{lstlisting}
rec tps: [ |-hastype M T] -> [ |-step M M'] -> [ |-hastype M' T] =
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       =>
  let [ |-t_pred _ ] = d in [ |-t_zero]
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         =>
  let [ |-t_pred D'] = d in
  let [ |-F] = tps [ |-D'] [ |-S'] in
    [ |-t_pred F]
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}


\paragraph{When is a program a proof?} So far we have just written a
functional program; for it to be a proof it needs to be a total
function, i.e. it must be defined on all inputs and it must be
terminating. We can check that the function is total in \beluga by
writing the following annotation before we start writing the body of
the function:\lstinline!/ total s (tps m t m' d s) /!. This
annotation states that we claim to implement program \lstinline!tps! that is
recursive in \lstinline!s!. Since in the statement we implicitly
quantify over term \lstinline!M! and \lstinline!M'! as well as the
type \lstinline!T! at the outside, we write in the totality \index{Totality}
declaration \lstinline!(tps m t m' d s)! indicating that we are
recursively analyzing the 4th argument (three of them are passed
implicitly) passed to \lstinline!tps!. The order in which the
implicit arguments are listed is irrelevant; what is important is
that their number is correct.
The full proof is then written as follows:


\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] =
/ total s (tps m t m' d s) /
fn d => fn s => case s of
| [|-e_if_true] =>
  let [|-t_if_then_else D D1 D2] = d in [|-D1]
| [|-e_if_false] =>
  let [|-t_if_then_else D D1 D2] = d in [|-D2]
| [|-e_if_then_else S] =>
  let [|-t_if_then_else D D1 D2] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_if_then_else D' D1 D2]
| [|-e_pred_zero] =>
  let [|-t_pred _ ] = d in  [|-t_zero]
| [|-e_pred_succ _ ] =>
  let [|-t_pred (t_succ D) ] = d in [|-D]
| [|-e_iszero_zero] =>
  let [|-t_iszero _] = d in [|-t_true]
| [|-e_iszero_succ _ ] =>
  let [|-t_iszero _] = d in [|-t_false]
| [|-e_pred S] =>
  let [|-t_pred D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_pred D']
| [|-e_succ S] =>
  let [|-t_succ D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_succ D']
| [|-e_iszero S] =>
  let [|-t_iszero D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_iszero D']
;
\end{lstlisting}

The full proof can be found online in the example directory
corresponding to this chapter (see \lstinline!Part1/type-preservation.bel!). %  \lstinline!evaluation.bel!.


\section{Uniqueness of Small-step Evaluation}\label{sec:unique-eval}
Next, we consider the proof that evaluation using the small-step rules yields a
unique value. This is an interesting proof because we must argue that values do
not step, i.e. there are no rules that apply. For \lstinline!zero!,
\lstinline!true! and \lstinline!false! this should be easy, since there is no
rule that applies. But how do we argue that \emph{every number} that is a value
does not step? - We prove a contradiction. We show inductively that if $M$ is a
value and $M \Steps M'$ then we can derive falsehood \index{Falsehood} (written as $\bot$).

\begin{theorem}
If $\proofderiv{\S}{M \Steps M'}$ and $\proofderiv{\V}{M \Value}$ then $\bot$.
\end{theorem}
\begin{proof}
By structural induction on the derivation $\proofderiv{\V}{M \Value}$.

\begin{basecase}{$\V = \ianc{}{\tmzero \Value}{}$}
$\proofderiv{\S}{\tmzero \Steps M'}$ \hfill by assumption \\
By inspecting all the existing rules, there exists no $M'$. Therefore, this
assumption is false, and from false we can derive anything; in particular, we
can conclude $\bot$.
\end{basecase}

\begin{stepcase}{$\V = \ianc{\above{\V'}{ N \Value}}{(\tmsucc N) \Value}{}$}
$\proofderiv{\S~}{(\tmsucc N) \Steps M'}$ \hfill by assumption \\
$\proofderiv{\S'}{N \Steps N'}$ \quad and \quad $M' = (\tmsucc N')$ \hfill by inversion using $\ESucc$\\
$\bot$ \hfill by i.h. using $\S'$ and $\V'$
\end{stepcase}

\end{proof}


How do we model in a programming environment $\bot$ (falsehood)? - In a
dependently typed language, we are modelling $\bot$ indirectly. Recall that
there is no way to for example construct an element of the type
\lstinline!step zero zero!.  If we think of the set of elements belonging to the type
\lstinline!step M M'!, then \lstinline!step zero zero! is not in it, but for
example \lstinline!step (pred zero) zero! is; so is
\lstinline!step (succ (pred zero)) (succ zero)!. Generally speaking, if we
define no elements
belonging to a type, then the type is guaranteed to be empty and models false.
In \beluga, we can define types without elements simply by declaring a type.

\begin{lstlisting}
not_possible: type.
\end{lstlisting}

We then can translate the theorem directly into a computation-level type in
\beluga; we have also included the totality \index{Totality} declaration, stating that this
function is recursively defined on values, i.e. object of type \lstinline![ |-value M]!.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
?
;
\end{lstlisting}

As before, we introduce the assumption \lstinline!s! for
\lstinline![|-step M M']! and \lstinline!v! for
\lstinline![|-value M]!. Then we case-analyze \lstinline!v!.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
fn s => fn v => case v of
| [ |-v_true]   => ?
| [ |-v_false]  => ?
| [ |-v_z ]     => ?
| [ |-v_s V']   => ?
;
\end{lstlisting}

Let's consider the case \lstinline![|-v_z] : [|-value zero]!. We argued in the
proof by ``By inspecting all the existing rules, there exists no $M'$.'' This
corresponds to case-analyzing \lstinline!s!; however, there are no cases. In
\beluga, we write \lstinline!impossible s! for splitting \lstinline!s! in
the empty context. It is effectively a case-expression without branches.

For the step-case, the translation of the proof to a program is more
straightforward: the inversion in the proof is translated to analyzing
\lstinline!s!; the appeal to the induction hypothesis corresponds to making a
recursive call.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
fn s => fn v => case v of
| [ |-v_true]   => impossible s
| [ |-v_false]  => impossible s
| [ |-v_z ]     => impossible s
| [ |-v_s V']   => let [ |-e_succ S'] = s in values_dont_step [ |-S'] [ |-V'];
\end{lstlisting}

One may wonder whether we can actually ever execute and run this program; the
answer is no, since there is no way to provide a derivation
\lstinline![|-step M M']! and at the same time a proof \lstinline![|-value M]!.


We are now ready to prove that evaluation yields a unique result given the
small-step semantics. This will illustrate how we can use the lemma \lstinline!values_dont_step!. We only show two cases, but the whole program is
available in the example directory corresponding to this chapter (see \lstinline!Part1/unique.bel!).

\begin{lstlisting}
LF equal: term -> term -> type =
| ref: equal T T;


rec unique : [|-step M M1] -> [|-step M M2] -> [ |-equal M1 M2] =
/ total s (unique m m1 m2 s)/
fn s1 => fn s2 => case s1 of
| [ |-e_if_true]  =>
  (case s2 of
   | [|-e_if_true]        => [|-ref]
   | [|-e_if_then_else D] => impossible values_dont_step [|-D] [|-v_true] )

| [ |-e_if_false] =>
  (case s2 of
   | [|-e_if_false]       => [|-ref]
   | [|-e_if_then_else D] => impossible values_dont_step [|-D] [|-v_false] )

| [ |-e_if_then_else D] =>
  (case s2 of
  | [|-e_if_true]        => impossible values_dont_step [|-D] [|-v_true]
  | [|-e_if_false]       => impossible values_dont_step [|-D] [|-v_false]
  | [|-e_if_then_else E] => let [ |-ref] = unique [|-D] [|-E] in  [|-ref] )

| [ |-e_succ D]        => ?
| [ |-e_pred_zero]     => ?
| [ |-e_pred_succ V]   => ?
| [ |-e_pred D]        => ?
| [ |-e_iszero_zero]   => ?
| [ |-e_iszero_succ V] => ?
| [ |-e_iszero D]      => ?
;
\end{lstlisting}

Let us consider the case where \lstinline!s1! is a derivation ending in
\lstinline![|-e_if_true]!, i.e. \lstinline!s1! stands for a derivation of
\lstinline![|-step (if_then_else true N1 N2) N1]!. At this point we know that \lstinline!s2! stands
for a derivation \lstinline![|-step (if_then_else true N1 N2) M2]!. Splitting
\lstinline!s2! into cases gives us two sub-cases:
\begin{enumerate}
\item We have used the rule
\lstinline!e_if_true!. In this case, we learn that
\lstinline!M2 = N1!. Clearly, we can conclude \lstinline![|-equal N1 N1]! by
using \lstinline![ |-ref]! as a witness.

\item We have used the rule \lstinline!e_if_then_else!. In this case, we have a
  sub-derivation \lstinline!D! that stands for \lstinline![ |-step true N']! and \lstinline!M2 = (if_then_else N' N1 N2)!.
We now use the lemma \lstinline!values_dont_step! passing \lstinline![|-D]! and \lstinline![|-v_true]! (a witness
for \lstinline![|-value true]!.
We therefore obtain an object of type \lstinline![|-not_possible]!; but no
elements of this type exist. This case is hence impossible.
\end{enumerate}

Next, consider the case where \lstinline!s1! is a derivation ending in
\lstinline![|-e_if_then_else D]!, i.e. \lstinline!s1! has type
\lstinline![|-step (if_then_else N N1 N2) (if_then_else N' N1 N2)]!. Hence \lstinline!D! stands for the sub-derivation
\lstinline![|-step N N']!. At this point we know that \lstinline!s2! stands
for a derivation \lstinline![|-step (if_then_else N N1 N2) M2]!. Splitting
\lstinline!s2! into cases gives us three sub-cases:

\begin{enumerate}
\item We have used the rule \lstinline!e_if_true!. As a consequence
  \lstinline!N = true! and \lstinline!M2 = N1!. Moreover,
  \lstinline!D! now stands for the sub-derivation \lstinline![|-step true N']!.
  Using again the lemma \lstinline!values_dont_step!, we show that this is impossible.

\item We have used the rule \lstinline!e_if_false!. This case is
  similar to the above.

\item We have used the rule \lstinline!e_if_then_else! and
  \lstinline!s2! stands for the derivation tree
\mbox{\lstinline![|-e_if_then_else E]!} where \lstinline!E! stands for a sub-derivation
\lstinline![|-step N N'']! and \lstinline!M2 = (if_then_else N' N1 N2)!.
We now make a recursive call on the sub-derivations \lstinline!D! and
\lstinline!E!, i.e. \lstinline!unique [|-D] [|-E]!, which gives us a
witness for
\mbox{\lstinline![|-equal N N']!}. By inversion using \lstinline!ref!, we learn that
\lstinline!N = N'!. To conclude the proof we need to provide a witness for
\lstinline![|-equal (if_then_else N N1 N2) (if_then_else N N1 N2)]!. This is easily
accomplished by \lstinline![|-ref]!. \\[0.5em]
It might look like we should be able to simply make a recursive call
and be done. This is
however a fallacy, since the type is incorrect. Recall that \lstinline!ref!
takes in an implicit argument for the term we are actually comparing; therefore
in the first occurrence \lstinline![|-ref]! stands actually for
\lstinline![|-ref <<N>>]!, while in the second occurrence it % \lstinline![|-ref]!
stands for \lstinline![|-ref <<(if_then_else N N1 N2)>>]!.\index{Implicit Arguments}
\end{enumerate}


\section{Termination of Well-typed Terms}
Our goal is to prove that the evaluation of well-typed terms halts. In
fact we already proved progress, i.e. evaluation cannot get stuck on
well-typed terms, i.e. either a well-typed term yields a value or we
can take another step. In this section we prove that we can always
evaluate a well-typed term to a final value.

\begin{theorem}
If $\proofderiv{\D}{t : T}$ then $t \Halts$, i.e.~there exists a value $v$ s.t. $t
\MSteps v$.
\end{theorem}

We recap our definition of multi-step relations that was the
reflexive, transitive closure over the single step relation.

\[
\begin{array}{c@{\qquad}c@{\qquad}c}
\infer[\MRef]{t \MSteps t}{} &
\infer[\MTr]{t \MSteps t'}{t \MSteps s & s \MSteps t'} &
\infer[\MStep]{t \MSteps t'}{t \Steps t'}
\end{array}
\]

Evaluation of a term $M$ may clearly not yield a value in one step; in fact we may need to chain multiple steps together.
In the proof for showing that well-typed terms terminate, we will see the need for lemmas that justify bigger steps when we evaluate a term.

\begin{lemma}[Multi Step Lemmas]~\label{lem:multi-step}
  \begin{enumerate}
  \item If $t \MSteps t'$ then $(\tmpred t) \MSteps (\tmpred t')$.
  \item If $t \MSteps t'$ then $(\tmsucc t) \MSteps (\tmsucc t')$.
  \item If $t \MSteps t'$ then $(\tmiszero t) \MSteps (\tmiszero t')$.
  \item If $t \MSteps t'$ then $(\tmif t {t_1} {t_2}) \MSteps (\tmif {t'} {t_1} {t_2})$.
  \end{enumerate}
\end{lemma}
\begin{proof}
By structural induction  on $\proofderiv{\S}{t \MSteps t'}$.  We'll only the last
proposition. By definition of $\MSteps$, we consider three cases:

\begin{basecase}{$\S = \ianc{t \Steps t'}{t \MSteps t'}{\MStep}$}
$\tmif{t_1}{t_2}{t_3} \Steps \tmif{t_1'}{t_2}{t_3}$ \hfill by rule $\EIf$ \\
$\tmif{t_1}{t_2}{t_3} \MSteps \tmif{t_1'}{t_2}{t_3}$ \hfill by rule $\MStep$
\end{basecase}

\begin{basecase}{$\S = \ianc{}{t_1 \MSteps t_1}{\MRef}$}
$\tmif{t_1}{t_2}{t_3} \longrightarrow^* \tmif{t_1'}{t_2}{t_3}$ \hfill
by rule $\MRef$
\end{basecase}

\begin{stepcase}{$\S = \ibnc{\above{\S_1}{t_1 \MSteps s}}{\above{\S_2}{s \MSteps t_1'}}{t_1 \MSteps t_1'}{\MTr}$}
$\tmif{t_1}{t_2}{t_3} \MSteps \tmif{s}{t_2}{t_3}$ \hfill by I.H. on $\S_1$\\
$\tmif{s}{t_2}{t_3} \MSteps \tmif{t_1'}{t_2}{t_3}$ \hfill by I.H. on $\S_2$\\
$\tmif{t_1}{t_2}{t_3} \MSteps \tmif{t_1'}{t_2}{t_3}$ \hfill by rule $\MTr$  \\
\end{stepcase}
\end{proof}

How would we mechanize this proof in \beluga? - This may seem
straightforward, but there are some subtleties. In the last statement,
we say

\begin{center}
If $t \MSteps t'$ then $(\tmif t {t_1} {t_2}) \MSteps (\tmif {t'} {t_1} {t_2})$.
\end{center}

It is important to realize that $t$, $t'$, $t_1$, and $t_2$ are all
univerally quantified.  When we appeal to the induction hypthtesis on
$\S_1$ we in fact instantiate and choose the appropriate $t_2$ and
$t_3$. It might be more precise to rewrite the statement to make this clearer.

\begin{center}
If $t \MSteps t'$ then for all $t_1$ and $t_2$, $(\tmif t {t_1} {t_2}) \MSteps (\tmif {t'} {t_1} {t_2})$.
\end{center}

Mechanizing proofs highlights such subtleties and forces us to
understand them and be more precise than in the on paper proof. We can
now translate the statement and the proof into
\beluga straitforwardly. We make explicite the quantification in the
statement writing \lstinline!{M2:[|- term}{M3:[|- term}!. In the
program, we use \lstinline!mlam!-abstraction as the corresponding
proof term for introducing a universal quantifier.\index{Universal
  quantification}\index{Explicit Arguments}

\begin{lstlisting}
rec mstep_if_then_else :  [ |- multi_step M M'] ->
   {M1:[ |- term]}{M2:[ |- term]}
   [ |- multi_step (if_then_else M M1 M2) (if_then_else M' M1 M2)] =
/ total ms (mstep_if_then_else _ _ ms)/
fn ms => case ms of
| [ |- ms_ref]      => mlam M1 => mlam M2 => [ |- ms_ref]
| [ |- ms_step S]   => mlam M1 => mlam M2 => [ |- ms_step (e_if_then_else S)]
| [ |- ms_tr S1 S2] => mlam M1 => mlam M2 =>
  let [ |- S1'] = mstep_if_then_else [ |- S1] [ |- M1 ] [ |- M2 ] in
  let [ |- S2'] = mstep_if_then_else [ |- S2] [ |- M1 ] [ |- M2 ] in
    [ |- ms_tr S1' S2']
;
\end{lstlisting}


Let us return to the goal of this section, namely of proving that the
evaluation of well-typed terms terminates. To prove this statement, we
need an additional lemma which justifies that multi-step relations
preserve types.

\begin{lemma}[Type preservation for multi-step relation]
If $M : T$ and $M \MSteps M'$ then $M':T$.
\end{lemma}
\begin{proof}
By structural induction on $M \MSteps M'$.
\end{proof}

Finally, we are ready to consider the proof that evaluation of well-typed terms
terminates. We first define $M \Halts$ as follows:

\[
\begin{array}{c}
\infer{M \Halts}{M \MSteps V & V \Value }
\end{array}
\]

Note that we are encoding existential quantification \index{Existential quantification} in the proposition ``there exists a value
$V$ s.t. $M \MSteps V$  in the theorem by defining a separate judgment
$M \Halts$. This trick allows us to turn an existential into a
universal quantifier, as the rule can be read as: For all $M$, $V$, if
$M \MSteps V$ and $V \Value$ then $M \Halts$.


\begin{proof}
By structural induction on $\proofderiv{\D}{M : T}$. We show a few
representative cases.

\begin{case}{$\D = \ianc{}{ \tmzero :\Nat}{\TZero}$}
$\tmzero \Value$ \hfill by $\VZero$ rule \\
$\tmzero \MSteps \tmzero$ \hfill by $\MRef$\\
$\tmzero \Value$ \hfill by definition $\VZero$\\
$\tmzero \Halts$ \hfill by definition of $\Halts$
\end{case}

\begin{case}{$\D = \ianc{\above{\D'}{ N : \Nat}}{ (\tmpred N) : \Nat}{\TPred}$}
$N \Halts$, i.e. $\exists V.$ s.t.$~\V':V\Value$ ~~and~~ $\S':N \MSteps V$ \hfill by I.H. $\D'$\\[1em]
%
\fbox{To Prove: ~~~$M\Halts$, i.e.$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$}\\[1em]
%
\begin{subcase}{$\V' = \ianc{}{\tmzero \Value}{\VZero}$ \quad and \quad $V = \tmzero$}
$\proofderiv{\S'}{N \MSteps \tmzero}$ \hfill restating assumption $\S'$\\
$\proofderiv{\S_0}{(\tmpred N) \MSteps (\tmpred \tmzero)}$ \hfill by lemma mstep-pred \\
$\proofderiv{\S_1}{(\tmpred \tmzero) \MSteps \tmzero}$ \hfill by $\MStep$ using $\EPredZ$\\
$\proofderiv{\S}{(\tmpred N) \MSteps \tmzero}$ \hfill by $\MTr$ using $\S_0$ and $\S_1$\\
$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$ \hfill by choosing
$W = \tmzero$\\
$(\tmpred N)\Halts$ \hfill by definition of $\Halts$\\[1em]
\end{subcase}
%
\noindent
\begin{subcase}{$\V' = \ianc{\above{\W}{V'\Value}}{(\tmsucc V') \Value}{\VSucc}$ \quad and \quad $V = \tmsucc V'$}
$\proofderiv{\S'}{N \MSteps (\tmsucc V')}$ \hfill restating assumption $\S'$\\
$\proofderiv{\S_0}{(\tmpred N) \MSteps (\tmpred (\tmsucc V'))}$ \hfill by lemma mstep-pred \\
$\proofderiv{\S_1}{(\tmpred (\tmsucc V')) \MSteps V'}$ \hfill by $\MStep$ using $\EPredSucc$ and $\W$\\
$\proofderiv{\S}{(\tmpred N) \MSteps V'}$ \hfill by $\MTr$ using $\S_0$ and $\S_1$\\
$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$ \hfill by choosing
$W = V'$\\
$(\tmpred N)\Halts$ \hfill by definition of $\Halts$\\[1em]
\end{subcase}
%
\noindent
\begin{subcase}{$\V' = \ianc{}{\tmtrue \Value}{\VTrue}$ \quad and \quad  $V = \tmtrue$}
$\proofderiv{\S'}{N \MSteps \tmtrue}$ \hfill restating assumption $\S'$\\
$\proofderiv{\F}{\tmtrue : \Nat}$ \hfill by type preservation for multi-step relations using $\D'$\\
$~~~ \bot$ \hfill \\[1em]
\end{subcase}
%
\noindent
\begin{subcase}{$\V' = \ianc{}{\tmfalse \Value}{\VFalse}$ \quad and \quad $V = \tmfalse$}
Similar to the case where $V = \tmtrue$.
\end{subcase}
\end{case}

\end{proof}


We now discuss how to mechanize this proof as a program. As a first step, we
must encode the statement of the theorem as a type.

\begin{lstlisting}
datatype halts: term -> type =
| result: multi_step M V -> value V
       -> halts M;

rec terminate : [|- hastype M T] -> [ |- halts M] =
/ total d (terminate m t d)/
fn d => ? ;
\end{lstlisting}

Again we encode the case analysis in the proof as a case analysis in the program
splitting on the assumption \lstinline!d!. We show below the cases we discussed
in detail above, however the full proof is implemented in the file
\lstinline!evaluation.bel!.

For the case where we have \lstinline!d:[|- hastype z nat]! by
\lstinline![|-t_zero]!, we return \lstinline![|-result ms_ref (v_zero)]! that
stands for a proof \lstinline![|- halts z]!. For the case where we have
\lstinline!d:[|-hastype (pred N) nat]! by \lstinline![|-t_pred D]! and
\lstinline!D! stands for a sub-derivation \lstinline![|- hastype N nat]!. By the
induction hypothesis on \lstinline!D! (i.e. modelled via the recursive call), we
obtain a proof that \lstinline![|- halts N]!.  By inversion, we know that this
proof has the following shape: \lstinline![|-result MS W]! where \lstinline!MS!
stands for \lstinline![|-multistep N R]! and \lstinline!W!
stands for a proof \lstinline![|-value R]!. We now case-analyze
\mbox{\lstinline![|-value R]!}.

If \lstinline!R=z! and we have a derivation
\lstinline![|-v_zero]!, we call our lemma \lstinline!mstep_pred! with
\lstinline!MS! to obtain a derivation \lstinline!MS'! for
\lstinline![|-multi_step (pred N) (pred z)]!. What remains is to build a proof
for \lstinline![|-halts (pred N)]!. First, we build a proof \lstinline![|-v_zero]!
that \lstinline![|-value z]!. Second, we build a proof for
\lstinline![|-multi_step (pred N) z]! using transitivity together with
\lstinline!MS'! and the derivation \lstinline![|-ms_step e_pred_zero]! for
\mbox{\lstinline![|-multi_step (pred N) z]!}.

If \lstinline!R=succ W! and we have a derivation
\lstinline!(v_succ V)!, we call our lemma \lstinline!mstep_pred! with
\lstinline!MS! to obtain a derivation \lstinline!MS'! for
\lstinline![|-multi_step (pred N) (pred (succ W))]!. What remains is to build a proof
for \lstinline![|-halts (pred N)]! using transitivity together with
\lstinline!MS'! and the derivation
\lstinline![|-ms_step (e_pred_succ V)]!.
%for
%\mbox{\lstinline![|-multi_step (pred N) W]!}.

If \lstinline!R=true! or \lstinline!R=false! then we know by the type
preservation lemma for multi-step relations implemented by the
function \lstinline!multi_tps! that we cannot take a step.



\begin{lstlisting}
rec terminate : [|-hastype M T] -> [ |-halts M] =
/ total d (terminate m t d)/
fn d => case d of
| [ |-t_true]  => ?
| [ |-t_false] => ?
| [ |-t_if_then_else D D1 D2] => ?
| [ |-t_zero] => [ |-result ms_ref v_zero]
| [ |-t_succ D] => ?
| [ |-t_pred D] => (case terminate [ |-D ] of
   | [ |-result MS (v_zero)] =>
     let [ |-MS']         = mstep_pred [ |-MS] in
       [ |-result (ms_tr MS' (ms_step e_pred_zero)) v_zero]
   | [ |-result MS (v_succ V)] =>
     let [ |-MS']         = mstep_pred [ |-MS] in
       [ |-result (ms_tr MS' (ms_step (e_pred_succ V)))  V]
   | [ |-result MS v_true] => impossible multi_tps [|-D] [|-MS]
   | [|-result MS v_false] => impossible multi_tps [|-D] [|-MS]
 )
| [|-t_iszero D] => ? ;
\end{lstlisting}

% \chapter{Exercise 3.5.17}

\section{Relating Small-step and Big-step Semantics}

\subsection{Definition of the big-step semantics}

% Almost taken from TAPL:
Two styles of operational semantics are in common use. The one used so far and
most commonly used in \cite{TAPL} is called the {\em small-step} style, because
the definition of the evaluation relation shows how individual steps of
computation are used to rewrite a term, bit by bit, until it eventually becomes
a value. On top of this, we define a multi-step evaluation relation that allows
us to talk about terms evaluating (in many steps) to values. An alternative
style, called {\em big-step} semantics (or sometimes {\em natural} semantics),
directly formulates the notion of ``the term $M$ evaluates to the final value $V$'',
written $M \BSteps V$. The big-step evaluation rules for our language of
boolean and arithmetic expressions can be described as follows:

\[
\begin{array}{c@{\qquad}c}
\multicolumn{2}{l}{\fbox{$M \BSteps V$}: \mbox{Term $M$ evaluates to value $V$}}\\[1em]
  \infer[\BValue]{V \BSteps V}{V \Value} &
  \infer[\BSucc]{\tmsucc M \BSteps \tmsucc V}{M \BSteps V}
\\[0.5em]
  \infer[\BPredZero]{\tmpred M \BSteps \tmzero}{M \BSteps \tmzero} &
  \infer[\BPredSucc]{\tmpred M \BSteps V}{M \BSteps \tmsucc V}
\\[0.5em]
  \infer[\BIszeroZero]{\tmiszero M \BSteps \tmtrue} {M \BSteps \tmzero} &
  \infer[\BIszeroSucc]{\tmiszero M \BSteps \tmfalse}{M \BSteps \tmsucc V}
\\[0.5em]
  \infer[\BIfTrue] {\tmif {M_1}{M_2}{M_3} \BSteps V}{M_1 \BSteps true  & M_2 \BSteps V} &
  \infer[\BIfFalse]{\tmif {M_1}{M_2}{M_3} \BSteps V}{M_1 \BSteps false & M_3 \BSteps V} \\
\end{array}
\]

Following the previous principle of encoding judgments such as $M \BSteps V$
using predicates (type families), we define in \beluga the relation
\lstinline!bigstep! between two terms using an LF type family. In the rules, we
do not enforce that we always return a value. Rather this is a property we can
prove and often referred to as value soundness.

\begin{lstlisting}
LF bigstep : term -> term -> type =
   | b_value       : value V
		     -> bigstep V V
   | b_succ        : bigstep M V
		     -> bigstep (succ M) (succ V)

   | b_pred_zero   : bigstep M z
		     -> bigstep (pred M) z
   | b_pred_succ   : bigstep M (succ V)
		     -> bigstep (pred M) V

   | b_iszero_zero : bigstep M z
		     -> bigstep (iszero M) true
   | b_iszero_succ : bigstep M (succ V)
		     -> bigstep (iszero M) false

   | b_if_true     : bigstep M1 true  -> bigstep M2 V
		     -> bigstep (if_then_else M1 M2 M3) V
   | b_if_false    : bigstep M1 false -> bigstep M3 V
		     -> bigstep (if_then_else M1 M2 M3) V
;
\end{lstlisting}

\subsection{Value soundness}

We will now prove two interesting things about values in the bigstep semantics.

\paragraph{Firstly} we can prove that, even if we didn't propagate the value
hypothesis in the whole bigstep constructor tree, we still always evaluate to a
value:

\begin{lemma}[Value Soundness for the Big-step semantics]
  \label{lem:bstep-value-soundness}
  ~\\If $M \BSteps V$, then $V$ is a value.
\end{lemma}

\begin{lstlisting}
rec bstep_value : [|- bigstep M V] -> [|- value V] =
/ total b (bstep_value _ _ b) /
  fn b => case b of 
  | [|- b_value E] => [|- E]
  | [|- b_succ B]  => let [|- E] = bstep_value [|- B] in [|- v_succ E]

  | [|- b_pred_zero B] => bstep_value [|- B]
  | [|- b_pred_succ B] => let [|- v_succ E] = bstep_value [|- B] in [|- E]

  | [|- b_iszero_zero B] => [|- v_true]
  | [|- b_iszero_succ B] => [|- v_false]

  | [|- b_if_true  B1 B2] => bstep_value [|- B2]
  | [|- b_if_false B1 B3] => bstep_value [|- B3]
;
\end{lstlisting}

\paragraph{Secondly} we can also prove that once we reach a value, we can't
reach an other one. Note that this is {\bf not} equivalent to say that only the
\BValue rule can apply. Indeed, there's two different ways of proving that
$\tmsucc \tmtrue \BSteps \tmsucc \tmtrue$:

\[
\begin{array}{c@{\qquad}c}
  \infer[\BValue]{\tmsucc \tmtrue \BSteps \tmsucc \tmtrue}
  {\infer[\VSucc]{\tmsucc \tmtrue \Value}
    {\infer[\VTrue]{\tmtrue \Value}{}}} &

  \infer[\BSucc]{\tmsucc \tmtrue \BSteps \tmsucc \tmtrue}
  {\infer[\BValue]{\tmtrue \BSteps \tmtrue}
    {\infer[\VTrue]{\tmtrue \Value}{}}}
\end{array}
\]

What we prove here for the bigstep semantics is the same property as the
``values don't step'' for the smallstep semantics, except that in our case,
values can continue evaluating over and over.

\begin{lemma}
  \label{lem:bstep-values-stagnate}
  If $V_1 \BSteps V_2$ with $V_1$ a value, then $V_1 = V_2$.
\end{lemma}

\begin{lstlisting}
rec bstep_values_stagnate : [|- bigstep V1 V2] -> [|- value V1] -> [|- equal V1 V2] =
/ total e (bstep_values_stagnate _ _ _ e) /
  fn b => fn e => case e of 
  | [|- v_zero]    => let [|- b_value _] = b in [|- ref]
  | [|- v_true]    => let [|- b_value _] = b in [|- ref]
  | [|- v_false]   => let [|- b_value _] = b in [|- ref]
  | [|- v_succ E'] =>
    (case b of 
     | [|- b_value _] => [|- ref]
     | [|- b_succ B'] =>
       let [|- ref] = bstep_values_stagnate [|- B'] [|- E'] in [|- ref]
    )
;
\end{lstlisting}

We now prove that the small-step and big-step semantics for this language
coincide, {\em i.e.} $M \MSteps V$ if and only if $M \BSteps V$, for any value
 $V$. We will prove the two directions of the ``if and only if'' separately.

\subsection{Part1: If $M \BSteps V$ then $M \MSteps V$}

Note that in this direction, we do not need to state that $V$ is a value, since
the Value Soundness Lemma (Lemma~\ref{lem:bstep-value-soundness}) gives us this
property for free.

This part of the proof follows exactly the one described in \cite{TAPL}. In the
proof, we rely on the Multi Step Lemmas (Lemma~\ref{lem:multi-step}) which we
proved in the last section. These lemmas justify bigger steps when evaluating a
term with the small-steps semantics which will be useful when we translate a
sequence of steps to a derivation tree in our big-step semantics. Let us now
write the actual proof:

\begin{proposition}[Big-step to small-step]
  \label{prop:bstep-to-mstep}
  If $M \BSteps V$ then $M \MSteps V.$
  \em
  \begin{lstlisting}
rec bstep_to_mstep : [|- bigstep M V] -> [|- multi_step M V] =
/ total b (bstep_to_mstep _ _ b) /
  fn b =>
  \end{lstlisting}
\end{proposition}

\begin{proof}
  By induction on the proof $\mathcal{B} := M \BSteps V$:
  \begin{itemize}
  \item Case $\infera{\BValue}{V \BSteps V}{V \Value}$\\
    By reflexivity of $\MSteps$, $V \MSteps V$.
    
  \item Case $\infera{\BPredZero}{\tmpred M \BSteps \tmzero}{M \BSteps \tmzero}$\\
    Since the proof in the premise is smaller than our proof $\mathcal{B}$, we
    can use the induction hypothesis and deduce $M \MSteps \tmzero$.\\
    Thanks to lemma~\ref{lem:multi-step}, we know that
    $\tmpred M \MSteps \tmpred z$.\\
    And since we know that $\tmpred \tmzero \Steps \tmzero$, we have 
    $\tmpred M \MSteps \tmpred \tmzero \Steps \tmzero$ and we just have to use
    the inclusion of $\Steps$ in $\MSteps$ and the transitivity of $\MSteps$ to
    conclude.

  \item Case $\inferaa{\BIfTrue}{\tmif{M_1}{M_2}{M_3} \BSteps V}{M_1 \BSteps \tmtrue}{M_2 \BSteps V}$\\
    Since the proofs in the premises are small than our proof $\mathcal{B}$, we
    can use the induction hypothesis and deduce $M_1 \MSteps \tmtrue$ and
    $M_2 \MSteps V$.\\
    Thanks to lemma~\ref{lem:multi-step}), we know then that\\
    $\tmif{M_1}{M_2}{M_3} \MSteps \tmif{\tmtrue}{M_2}{M_3}$.\\
    We then have:
    \begin{align*}
      \tmif{M_1}{M_2}{M_3} &\MSteps \tmif{\tmtrue}{M_2}{M_3} \\
                           &\Steps  M_2                      \\
                           &\MSteps V
    \end{align*}
    And we just have to use the inclusion of $\Steps$ in $\MSteps$ and the
    transitivity of $\MSteps$ to conclude.
  \end{itemize}

  ~

  \begin{lstlisting}
  case b of

  | [|- b_value _] => [|- ms_ref]

  | [|- b_pred_zero B] =>
    let [|- S] = bstep_to_mstep [|- B] in
    let [|- S'] = mstep_pred [|- S] in
    [|- ms_tr S' (ms_step e_pred_zero)]

  | [|- b_if_true  B1 B2] : [|- bigstep (if_then_else _ M2 M3) _] =>
    let [|- S1] = bstep_to_mstep [|- B1] in
    let [|- S2] = bstep_to_mstep [|- B2] in
    let [|- S1'] = mstep_if_then_else [|- S1] [|- M2] [|- M3] in
    [|- ms_tr (ms_tr S1' (ms_step e_if_true)) S2]
  \end{lstlisting}
\end{proof}

A really interesting line in this proof is the following one:
\begin{center}
\lstinline!| [|- b_if_true  B1 B2] : [|- bigstep (if_then_else _ M2 M3) _] =>!
\end{center}
The second part of the pattern is not syntactically necessary. In our case, it
is used to give a name to the terms $M_2$ and $M_3$, because we will need them
to use the lemma \lstinline!mstep_if_then_else!.
\todo{Explain this a little better? I don't know what to say. -nj}

\subsection{Part~2: If $M \MSteps V$ with $V$ a value then $M \BSteps V$ }

This direction is not as immediate as the first one. This comes essentially from
the fact that the bigstep relation must be between a term and a value, while the
multistep relation can be between two terms.

This is the reason why we will need to say that $V$ is a value (we didn't need
it in the Part~1), and this is the reason why we will have to use lemmas that
will take a multistep relation between two terms, and a bigstep relation
starting from the second term and finishing the evaluation to the value.
\todo{This is really not clear, but I don't know how to say it. -nj}

\begin{lemma}\label{lem:step-bstep-to-bstep}
  If $M \Steps N \BSteps V$ then $M \BSteps V$.
  \em
  \begin{lstlisting}
rec step_bstep_to_bstep : [|- step M N] -> [|- bigstep N V] -> [|- bigstep M V] =
/ total s (step_bstep_to_bstep _ _ _ s _) /
  fn s => fn b =>
  \end{lstlisting}
\end{lemma}

This is the hardest part. Indeed, once we will have this lemma, we will only
have to iterate over the $\Steps$ to get the same property for $\MSteps$:

\begin{lemma}\label{lem:mstep-bstep-to-bstep}
  If $M \MSteps N \BSteps V$ then $M \Downarrow V$.
  \em
  \begin{lstlisting}
rec mstep_bstep_to_bstep : [|- multi_step M N] -> [|- bigstep N V]
			   -> [|- bigstep M V] =
/ total s (mstep_bstep_to_bstep _ _ _ s _) /
  fn s => fn b =>
  \end{lstlisting}
\end{lemma}

And then we will just have to apply this lemma with $N = V$ to obtain what we
want:

\begin{proposition}\label{prop:mstep-to-bstep}
  If $M \MSteps V$ with $V$ a value then $M \BSteps V$.
  \em
  \begin{lstlisting}
rec mstep_to_bstep : [|- multi_step M V] -> [|- value V] -> [|- bigstep M V] =
/ total s (mstep_to_bstep _ _ s _) /
  fn s => fn v =>
  \end{lstlisting}
\end{proposition}

Let's now proof the hard part:

\begin{proof}[Proof of lemma~\ref{lem:step-bstep-to-bstep}]
  By induction on the proof $\mathcal{S}$ of $M \Steps N$:
  \begin{itemize}
  \item Case $\tmif{\tmtrue}{M_2}{M_3} \Steps M_2$\\
    We know that $\tmtrue \BSteps \tmtrue$ and that $M_2 \BSteps V$. Which means
    we can directly conclude:
    \[ \inferaa{\BIfTrue}{\tmif{\tmtrue}{M_2}{M_3} \BSteps V}{\infera{\BValue}{\tmtrue \BSteps \tmtrue}{\infera{\VTrue}{\tmtrue \Value}{}}}{M_2 \BSteps V} \]

  \item Case $\infera{\EPredSucc}{\tmpred \tmsucc V \Steps V}{V \Value}$\\
    Since $V$ is a value, and since we know that values stagnate, we know that
    we just have to show a bigstep reduction to $V$, and there it is:
    \[ \infera{\BPredSucc}{\tmpred \tmsucc V \BSteps V}{\infera{\BValue}{\tmsucc V \BSteps \tmsucc V}{\infera{\VSucc}{\tmsucc V \Value}{V \Value}}} \]

  \item Case $\infera{\EIf}{\tmif{M_1}{M_2}{M_3} \Steps \tmif{M_1'}{M_2}{M_3}}{M_1 \Steps M_1'}$\\
    Let's notice that after such a step, there can be three bigstep rules:
    \begin{itemize}
      \item A \BValue rule, but this is not possible since a $\tmif{M_1'}{M_2}{M_3}$ cannot be a
        value.
      \item A \BIfTrue rule. In that case, it will give us a proof for
        $M_1' \BSteps \tmtrue$ and an other one for $M_2 \BSteps V$. We can then
        apply our induction hypothesis on $M_1 \Steps M_1' \BSteps \tmtrue$,
        obtain a proof for $M_1 \BSteps \tmtrue$ and conclude:
        \[ \inferaa{\BIfTrue}{\tmif{M_1}{M_2}{M_3} \BSteps V}{M_1 \BSteps \tmtrue}{M_2 \BSteps V} \]
      \item A \BIfFalse rule, which is exactly the same thing.
    \end{itemize}

  \item Case $\infera{\ESucc}{\tmsucc M \Steps \tmsucc N}{M \Steps N}$\\
    Once again, after this step, we can have two different bigstep rules:
    \begin{itemize}
    \item A \BValue rule. Which means that $\tmsucc N$ is a value, which means
      that $N$ is a value. We can then use the induction hypothesis on
      $M \Steps N \BSteps N$ and get a proof of $M \BSteps N$. And then
      conclude:
      \[ \infera{\BSucc}{\tmsucc M \BSteps \tmsucc N}{M \BSteps N} \]
    \item A \BSucc rule. Which means we have something like that:
      \[ \infera{\ESucc and \BSucc}{\tmsucc M \Steps \tmsucc N \BSteps \tmsucc V'}{M \Steps N \BSteps V'} \]
      We apply the induction hypothesis, obtain a proof of $M \BSteps V'$ and we
      can conclude:
      \[ \infera{\BSucc}{\tmsucc M \BSteps \tmsucc V'}{M \BSteps V'} \]
    \end{itemize}
  \end{itemize}
  ~
  \begin{lstlisting}
  let [|- B] = b in
  case s of 

  | [|- e_if_true] =>
    [|- b_if_true (b_value v_true) B]

  | [|- e_pred_succ E] =>
    let [|- ref] = bstep_values_stagnate [|- B] [|- E] in
    [|- b_pred_succ (b_value (v_succ E))]

  | [|- e_if_then_else S] =>
    (case [|- B] of 
     | [|- b_value E] => impossible [|- E]
     | [|- b_if_true  B1' B2'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_if_true  B1 B2']
     | [|- b_if_false B1' B3'] =>
       let [|- B1] = step_bstep_to_bstep [|- S] [|- B1'] in
       [|- b_if_false B1 B3']
    )

  | [|- e_succ S] =>
    (case [|- B] of 
     | [|- b_value E] =>
       let [|- v_succ E'] = [|- E] in
       let [|- B'] = step_bstep_to_bstep [|- S] [|- b_value E'] in
       [|- b_succ B']
     | [|- b_succ B] =>
       let [|- B'] = step_bstep_to_bstep [|- S] [|- B] in
       [|- b_succ B']
    )
  \end{lstlisting}
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
