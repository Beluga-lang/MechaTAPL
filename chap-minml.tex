\chapter{The Basics: Mechanizing languages and proofs}

\begin{quote}
``A language that doesn't affect the way you think about programming, is
not worth knowing.''
\hfill - Alan Perlis
\end{quote}

Definitions of programming languages  typically cover three fundamental aspects:
the grammar  of the language,  i.e. what are syntactically  well-formed terms in
the language,  its operational semantics,  i.e. how do we execute and evaluate a
given term,  and its  type structure, i.e. what are  well-typed expressions.  We
revisit  these concepts  for  a small language  containing booleans  and numbers
following \citep[Ch 3,Ch 8]{TAPL} in  preparation for representing this language
together with its operational semantics and type system in \beluga.

\section{Encoding the language and its definitions}

\subsection{Terms: Booleans and Numbers}

Let  us  consider  a simple language  containing booleans,  if-expressions,  and
numbers together  with simple operations  that allow us  to test whether a given
number is zero (see \cite[Ch 3, Fig 3-1,Fig 3-2]{TAPL}). We define numbers using
$\tmzero$ and $\tmsucc$-operation.  To analyze  and manipulate numbers,  we also
provide a $\tmpred$-operator.

\[
\begin{array}{ll@{\bnfas}l}
\mbox{Terms} & t & \tmfalse \bnfalt \tmtrue \bnfalt \tmif t t t \bnfalt
\tmzero \bnfalt \tmsucc t \bnfalt \tmpred t \bnfalt \tmiszero t
\end{array}
\]

The first question  we investigate is  how to define  and represent terms in the
proof  enviroment  \beluga. To represent  terms  in \beluga,  we declare  a type
\lstinline!term!  for  terms   together  with  constants  corresponding  to  the
constructors    $\tmfalse$,   $\tmtrue$,    $\tmzero$,   $\tmsucc$,   $\tmpred$,
$\tmiszero$,  etc.   More   precisely   we   use   the   logical   framework  LF
\citep{Harper93jacm} for introducing new types such as \lstinline!term! together
with constants  \lstinline!true!,  \lstinline!false!, etc.  that  can be used to
construct terms. All constants are used as prefix operators by default.

\begin{lstlisting}
LF term : type =
| true         : term
| false        : term
| if_then_else : term -> term -> term -> term
| z            : term
| succ         : term -> term
| pred         : term -> term
| iszero       : term -> term
;
\end{lstlisting}

To illustrate consider a few examples:

\begin{center}
\begin{tabular}{l@{\quad is represented as \quad}l}
%\multicolumn{1}{c}{On paper} & & \multicolumn{1}{c}{Code}\\[0.5em]
$\tmif \tmfalse \tmzero {\tmsucc \tmzero}$ &
\lstinline!if_then_else false z (succ z)!\\
$\tmiszero (\tmpred (\tmsucc \tmzero))$ & \lstinline!iszero (pred (succ z))!.
\end{tabular}  
\end{center}

% We can declare infix
% operator by using the keyword \lstinline!%infix!.

\subsection{Small Step Semantics}

Next,  we define  the small-step semantics  for our  little language.  This will
describe  how  we evaluate  a  given term.  To give  a  deterministic evaluation
strategy,  it is convenient to first define what the values of our language.  In
\cite{TAPL}, we distinguished between terms and values in the grammar itself and
we think of values  as a sub-class of terms;  here we take  a slightly different
approach and define explicitly  what it means  to be a value using the judgments
$t \NumValue$ and $t \Value$.  We can think of these judgments  as predicates on
terms which are defined  {\em via}  axioms and inference rules.  A term $t$ is a
numeric value iff we can give a derivation for $t \NumValue$, and a value iff we
can give a derivation for $t \Value$.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$t \NumValue$}: \mbox{Term $t$ is a numeric value}}\\[1em]
\infer[\NVZero]{\tmzero \NumValue}{} \qquad
\infer[\NVSucc]{(\tmsucc t) \NumValue}{t \NumValue} \qquad
\end{array}
\]

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$e \Value$}: \mbox{Expression $e$ is a value}}\\[1em]
\infer[\VNumValue]{t \Value}{t \NumValue} \qquad
\infer[\VTrue]{\tmtrue \Value}{} \qquad
\infer[\VFalse]{\tmfalse \Value}{} \qquad
\end{array}
\]

Here, we identify $\tmzero$ as a numeric value; in addition, $\tmsucc t$ is a
numeric value provided that $t$ is a numeric value. We also identify $\tmtrue$
and $\tmfalse$ as values, and say that every numeric value is a value.

We are now ready to define when a term $t_1$ steps to another term $t_1'$ using
the judgment $t_1 \Steps t_1'$ using congruence rules and reduction rules.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$t_1 \Steps t_1'$}: \mbox{Term $t_1$ steps to term $t_1'$}}
\\[1em]
\multicolumn{1}{l}{\mbox{\text{Congruence Rules}}}
\\[1em]
\infer[\ESucc]{\tmsucc t_1 \Steps \tmsucc t_1'}{t_1 \Steps t_1'}\qquad
\infer[\EPred]{\tmpred t_1 \Steps \tmpred t_1'}{t_1 \Steps t_1'}
\\[1em]
\infer[\EIsZero]{\tmiszero t_1 \Steps \tmiszero t_1'}{t_1 \Steps t_1'}\qquad
\infer[\EIf]{\tmif{t_1}{t_2}{t_3} \Steps \tmif{t_1'}{t_2}{t_3}}{t_1 \Steps t_1'}
\\[1em]
\multicolumn{1}{l}{\mbox{\text{Reduction Rules (Axioms)}}}
\\[1em]
\infer[\EPredZ]{\tmpred \tmzero \Steps \tmzero}{}\qquad
\infer[\EPredSucc]{\tmpred (\tmsucc nv_1) \Steps nv_1}{nv_1 \NumValue}
\\[1em]
\infer[\EIsZeroZ]{\tmiszero \tmzero \Steps \tmtrue}{} \qquad
\infer[\EIsZeroSucc]{\tmiszero (\tmsucc nv_1) \Steps \tmfalse}{nv_1 \NumValue}
\\[1em]
\infer[\EIfT]{\tmif \tmtrue {t_2}{t_3} \Steps t_2}{}\qquad
\infer[\EIfF]{\tmif \tmfalse {t_2}{t_3} \Steps t_3}{}
\end{array}
\]

Our  goal  is  to  represent  the  relation  $t_1 \Steps t_1'$ and  describe the
derivation trees which correspond to evaluating a given sub-term.
To accomplish this we also must be able to construct derivation trees that prove
that  a given  term is  a value  or a  numeric  value. Recall  that a  data-type
provides us with definition of constructing elements.
Clearly,  terms  are  inductively  defined  and  are  easily  translated  into a
data-type definition. However,  we also defined inductively  what it means for a
term  to be a value or a numeric value:  we use the  axioms $\NVZero$, $\VTrue$,
$\VFalse$  together  with  the   inference  rules  $\NVSucc$  and  $\VNumValue$.
Similarly,  we defined inductively  what it means for a term $t_1$  to step to a
term $t_1'$.
In \beluga, data-types are powerfull enough to encode such definitions
about  predicates  and  relations.  To represent the judgment  $t \NumValue$  we
define  a predicate (type family) \lstinline!num_value!  and state that it takes
terms as argument  by declaring its type as \lstinline!term -> type!.  Then each
rule corresponds to a constructor in our data-type definition. A derivation tree
then corresponds to an expression formed by these constructors.

\begin{lstlisting}
LF num_value : term -> type =
| nv_zero     : num_value z
| nv_succ     : num_value V -> num_value (succ V)
;

LF value : term -> type =
| v_num_value : num_value M -> value M
| v_true      : value true
| v_false     : value false
;
\end{lstlisting}

In our definition  of  the constructor \lstinline!nv_succ!, the  capital  letter
\lstinline!M! describes numerical values and is thought  to be  universally
quantified  at the outside.  We can hence read the constructor \lstinline!nv_succ! as follows:

\begin{center}
\begin{tabular}{p{12cm}}
``For  all  terms   \lstinline$M$,   if   \lstinline!D!  is  a  derivation   for
\lstinline!num_value M!,      then      we     can     form     a     derivation
\lstinline!(nv_succ <<M>> D)! for \lstinline!num_value (succ M)!.''
\end{tabular}
\end{center}


We mark here  the term \lstinline!<<N>>! in green  since in practice programmers
can omit  writing it  and \beluga  will infer it.  The recipe is  ``if we do not
explicitly quantify over variables in the definition of a constructor, we do not
need  to pass instantiations  for them when constructing objects  using the said
constructor.''

To illustrate consider the following concrete example.\\[1em]

\begin{tabular}{l@{\qquad}l}
The derivation &
$
\infer[\NVSucc]
  { (\tmsucc (\tmsucc \tmzero)) \NumValue }
  { \infer[\NVSucc]
      { (\tmsucc \tmzero)~\NumValue }
      { \infer[\NVZero]
          {\tmzero \NumValue}
          {}
      }
  }
$\\[1em]
is represented as &
\lstinline!(nv_succ <<(succ z)>> (nv_succ <<z>> v_zero))!\\[1em]
\end{tabular}

In \beluga, we simply write

\begin{lstlisting}
  let v : [|- num_value (succ (succ z))] = [|- nv_succ (nv_succ nv_zero)];
\end{lstlisting}  



We bind the derivation to the name \lstinline!v!  and declare that \lstinline!v!
has type \lstinline![|- num_value (succ (succ z))]!.  Note,  we in general write
derivations using \lstinline!|-!.  On the left hand side  of this symbol  we can
list assumptions and the right hand side describes  what we claim can be derived
from these assumptions.  For example, we might say:

\begin{lstlisting}
  let w : [x: term, nv: num_value x |- num_value (succ (succ x))] =
      [x: term, nv: num_value x |- nv_succ (nv_succ nv)];
\end{lstlisting}

The  right  hand  side   can  be  read  as:   Assuming  \lstinline!x: term!  and
\lstinline!nv: num_value x!,  i.e. \lstinline!nv!  is the derivation that states
that \lstinline!x! is  a numerical value,  then \lstinline!nv_succ (nv_succ nv)!
is the witness for the fact that \lstinline!succ (succ x)! is a numerical value.

We can similarly  encode the small-step relation  $t_1 \Steps t_1'$  between the
terms $t_1$ and $t_1'$ using the type family/relation \lstinline!step!.

\begin{lstlisting}
LF step: term -> term -> type =
| e_if_true      : step (if_then_else true M2 M3) M2
| e_if_false     : step (if_then_else false M2 M3) M3
| e_pred_zero    : step (pred z) z
| e_pred_succ    : num_value NV1
                   -> step (pred (succ NV1)) NV1
| e_iszero_zero  : step (iszero z) true
| e_iszero_succ  : num_value NV1
                   -> step (iszero (succ NV1)) false
| e_if_then_else : step M1 M1'
                   -> step (if_then_else M1 M2 M3) (if_then_else M1' M2 M3)
| e_succ         : step M1 M1'
                   -> step (succ M1) (succ M1')
| e_pred         : step M1 M1'
                   -> step (pred M1) (pred M1')
| e_iszero       : step M1 M1'
                   -> step (iszero M1) (iszero M1')
;
\end{lstlisting}

Next,  we show a few examples of  how to encode and represent derivations that a
concrete term steps to another.

\begin{lstlisting}
let e1 : [|- step (pred (succ (pred z))) (pred (succ z))] =
         [|- e_pred (e_succ e_pred_zero)] ;

let e2 : [|- step (pred (succ z)) z] = [|- e_pred_succ nv_zero] ;
\end{lstlisting}

Here \lstinline!e1! stands for the derivation

\[
\begin{array}{c}
\infer[\EPred]{(\tmpred {(\tmsucc {(\tmpred {\tmzero})})}) \Steps (\tmpred {(\tmsucc {\tmzero})})}
{\infer[\ESucc]{(\tmsucc {(\tmpred {\tmzero})}) \Steps (\tmsucc {\tmzero} )}
 {\infer[\EPredZ]{(\tmpred {\tmzero}) \Steps \tmzero}{}}
}
\end{array}
\]

The name \lstinline!e2! stands for the derivation consisting of only
the rule $\EPredSucc$.

\section{Typing Rules}

Finally, we remark that following these ideas, we can encode typing rules for
our term language by representing the typing judgment $t : T$ using the type
family (relation) \lstinline!hastype!. Our language so far has only two types,
namely $\Bool$ and $\Nat$.

\[
\begin{array}{lll}
\mbox{Types} & T \bnfas & \Bool \mid \Nat
\end{array}
\]

We encode these types in \beluga using the LF type \lstinline!tp! together with
two constants \lstinline!bool! and \lstinline!nat!.

\begin{lstlisting}
LF tp : type =
| bool : tp
| nat : tp
;
\end{lstlisting}

The typing rules relate terms to types. We recall here simply the typing rules from \cite{TAPL}.

\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$t \hastype T$}: \mbox{Term $t$ has type $T$}}\\[1em]
  \infer[\TTrue]{\tmtrue \hastype \Bool}{} \qquad
  \infer[\TFalse]{\tmfalse \hastype \Bool}{} \qquad
  \infer[\TIf]{\tmif{t_1}{t_2}{t_3} \hastype T}{t_1 \hastype \Bool & t_2 \hastype T & t_3 \hastype T}
\\[0.5em]
  \infer[\TZero]{\tmzero \hastype \Nat}{}\quad
  \infer[\TSucc]{\tmsucc t_1 \hastype \Nat}{t_1 \hastype \Nat} \quad
  \infer[\TPred]{\tmpred t_1 \hastype \Nat}{t_1 \hastype \Nat} \quad
  \infer[\TIsZero]{\tmiszero t_1 \hastype \Bool}{t_1 \hastype \Nat}
\\
\end{array}
\]

The typing relation between terms and types is encoded in \beluga using a
predicate (type family) \lstinline!hastype! which is declared with
\lstinline!term -> tp -> type!. Each typing rule corresponds to a constructor in
our data-type definition. 

\begin{lstlisting}
LF hastype : term -> tp -> type =
| t_zero  : hastype z nat
| t_succ  : hastype M nat
         -> hastype (succ M) nat
| t_pred  : hastype M nat
         -> hastype (pred M) nat
| t_true  : hastype true bool
| t_false : hastype false bool
| t_iszero: hastype M nat
         -> hastype (iszero M) bool
| t_if_then_else: hastype M1 bool -> hastype M2 T -> hastype M3 T
         -> hastype (if_then_else M1 M2 M3) T
;
\end{lstlisting} 

\section{Encoding Proofs}

We now discuss some standard properties about languages which are also discussed
in \cite{TAPL} and show how we can represent such proofs as total functions that
manipulate and analyze derivation trees. In particular, we illustrate:

\begin{itemize}
\item How to represent inductive proofs about derivations as total functions 
\item How to prove that a case is impossible
\item How to state a property universally about terms and reason by induction on
  terms (rather than derivations)
\end{itemize}

We develop each example step-wise using the interactive programming features in \beluga.

\subsection{Type preservation: A Simple Proof by Structural Induction} The first property we re-visit is type
preservation. In particular, we write $\vdash t : T$ and $\vdash t
\Steps t'$ to clearly state that we only consider closed terms.

\begin{theorem}
If   $\proofderivc{\D}{}{t : T}$ and $\proofderiv{\S}{t \Steps t'}$ then $\vdash t' : T$.
\end{theorem}
\begin{proof}
By structural induction on the derivation $\proofderiv{\S}{t \Steps t'}$. We
consider here only a few cases.

\begin{case}{$\S = \ianc{}{\tmpred \tmzero \Steps \tmzero}{\EPredZ}$}
$\proofderivc{\D~}{}{\tmpred {\tmzero} : T}$ \hfill by assumption\\
$\proofderivc{\D'}{}{\tmzero : \Nat}$ \quad and \quad $T = \Nat$ \hfill by inversion using rule $\TPred$ \\
$\proofderivc{~~~~}{}{\tmzero : \Nat}$ \hfill by rule $\TZero$.
\end{case}

\begin{case}{$\S = \ianc{\above{\S '}{M \Steps M'}}{(\tmpred M) \Steps (\tmpred M')}{\EPred}$}
$\proofderivc{\D~}{}{\tmpred M : T}$ \hfill by assumption \\
$\proofderivc{\D'}{}{M : \Nat}$ \quad and \quad $T = \Nat$ \hfill by inversion using rule $\TPred$ \\
$\proofderivc{\F~}{}{M' : \Nat}$ \hfill by IH using $\D'$ and $\S'$\\
$\proofderivc{~~~~}{}{\tmpred M' : \Nat}$ \hfill by rule $\TPred$.
\end{case}

\end{proof}


An inductive proof as the one here can be interpreted as recursive
function where case-analysis in the proof corresponds to case analysis
in the program and the appeal to the IH corresponds to making a
recursive call. From a program point of view, we can read the type
preservation theorem as: Given a typing derivation $\vdash t:T$ and a derivation
for $\vdash t \Steps t'$, we return a typing derivation $\vdash t':T$.

We begin by translating and representing the actual theorem statement
in \beluga. This is straightforward keeping in mind that

\begin{center}
\begin{tabular}{l|l}
On paper judgment~~ & ~~Type in \beluga \\
\hline
$\vdash t :T$ & \lstinline![ |-hastype M T]! \\
$\vdash t \Steps t'$ & \lstinline![ |-steps M M']! \\
\end{tabular}
\end{center}

Note that we represent terms, written on paper using $t$ and $s$, using capital
letters \lstinline!M! and \lstinline!N! to differentiate better between types
and terms.

\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] = ? ;
\end{lstlisting}

Note that \lstinline!->! is overloaded. We have used it so far in defining
the type families \lstinline!hastype!, \lstinline!step!,
\lstinline!value!, and the type \lstinline!term!. The arrow in these
data-type definitions corresponded to the line we draw, when we draw an
inference rule to distinguish between the premises and the
conclusions. We merely were using the arrow to define syntactic
structures.

In \beluga, we strictly separate between the objects we are
constructing (such as derivation trees, terms, etc.) from proofs about
them. The type preservation statement makes a claim about typing
stepping derivations. In the type of the function \lstinline!tps! the
function type \lstinline!->! is much stronger; it for example allows us to write
recursive functions which analyze objects of type \lstinline![|-hastype M T]! and
\lstinline![|-step M M'! by pattern matching.

Last, we wrote \lstinline!?!. This is very useful when developing and
debugging proofs/programs, since it allows us to describe incomplete
proofs/programs and \beluga will print back to you the assumptions at
that given point and the goal which needs to be proven.
Let's fill in some of the details.

\paragraph{Introducing assumptions - Writing functions} Since we are proving an
implication, we introduce two assumptions \lstinline!d:[|-hastype M T]! and
\lstinline!s:[|-step M M']! and try to establish
\lstinline![|-hastype M' T]!. From a programmer's point of view, we need
to build a function that when given \lstinline!d:[|-hastype M T]! and
\lstinline!s:[|-step M M']! returns a derivation of type
\lstinline![|-hastype M' T]!. We use a concrete syntax similar to
ML-like languages writing

\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] = ? ;
fn d => fn s = ? ;
\end{lstlisting}


\paragraph{Case analysis - Pattern matching} Next, we split the proof
into different cases analyzing $\S : M \Steps M'$. This corresponds
to pattern matching on \lstinline!s:[|-step M M']! in our program.

\begin{lstlisting}
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       => ?
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         => ?
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}

We sometimes use \lstinline!_! (underscore) for an argument, if we do
not need a name for it, since it does not play a role in the
proof. For example, when we represent the derivation\\[1em] $\S =
\ianc{M \Value}{\tmpred ({\tmsucc M}) \Steps M}{\EPredSucc}$ we simply
write \lstinline![|-e_pred_suc _]! since the subderivation
representing $M \Value$ is not used in proving that types are preserved.
\\[1em]
\emph{Convention:} Variables describing sub-derivations,
i.e. variables occurring inside \lstinline![   ]! must be
upper-case. Variables describing proper assumptions in the proof,
i.e. variables introduced by \lstinline!fn!-abstraction, must be lower
case.

\paragraph{Proving - Programming} Let us now implement the two cases
in the type preservation proof we discussed earlier. We start with the
case \lstinline![e_pred_zero]! which corresponds to the base case in
our proof. Pattern matching in \lstinline!s! has not only generated
all the caes, but more importantly it has refined what $M$ and $M'$
stand for. In this particular case, \lstinline!M = (pred z)! and
\lstinline!M' = z!. As a first step in the proof, we analyzed the assumption
\lstinline!d:[|-hastype (pred z) T]! further. We case-analyzed this
assumption and we stated ``by inversion on $\TPred$'' which indicated
that there was exactly one case.

While we certainly can write another case-expression analyzing
\lstinline!d! in the proof, \beluga provides syntactic sugar for
case-expressions with one case; instead of writing

\noindent
\lstinline!case d of [ |-t_pred D'] => ? ! we simply write
\lstinline!let [ |-t_pred D'] = e in ?!.


We now have learned that \lstinline!T = nat!.

\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] =
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       =>
  let [|-t_pred _ ] = d in ?
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         => ?
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}

\beluga will compile this partial program and print for the hole

\begin{lstlisting}
________________________________________________________________________________
- Meta-Context: .
________________________________________________________________________________
- Context:
tps: [ |-hastype M T] -> [ |-step M M'] -> [ |-hastype M' T]
d: [ |-hastype (pred z) nat]
s: [ |-step (pred z) z]

================================================================================
 - Goal Type: [ |-hastype z nat]

\end{lstlisting}



We now need to build an object that has type
\lstinline![ |-hastype z nat]!. This can simply be achieved by
providing
\lstinline![ |-t_zero]!.


For the step case where we are considering the case
\lstinline![ |-e_pred S']!, we also proceeded by analyzing
\lstinline!d:[ |-hastype (pred N) T]! by pattern matching. There is
only one constructor that could have been used to build \lstinline!d!
and we hence know that it must be of the form
\lstinline![ |-t_pred D']! where \lstinline!D'! stands for a
derivation
\lstinline![ |-hastype N nat]! and we learn that \lstinline!T=nat!.

We then appeal to the induction hypothesis in the proof
using \lstinline!S! and \lstinline!D'!. This corresponds to making a
recursive call \lstinline!tps [|-D'] [|-S']! and we name the resulting
derivation \lstinline![|-F]!. Finally, we construct our derivation
\lstinline![ |-t_pred F]! for \lstinline![ |-hastype (pred N') nat]!.

\begin{lstlisting}
rec tps: [ |-hastype M T] -> [ |-step M M'] -> [ |-hastype M' T] =
fn d => fn s => case s of
| [ |-e_if_true]         => ?
| [ |-e_if_false]        => ?
| [ |-e_if_then_else S'] => ?
| [ |-e_pred_zero]       =>
  let [ |-t_pred _ ] = d in [ |-t_zero]
| [ |-e_pred_succ _]     => ?
| [ |-e_iszero_zero]     => ?
| [ |-e_iszero_succ _ ]  => ?
| [ |-e_pred S']         =>
  let [ |-t_pred D'] = d in
  let [ |-F] = tps [ |-D'] [ |-S'] in
    [ |-t_pred F]
| [ |-e_succ S']         => ?
| [ |-e_iszero S']       => ?
;
\end{lstlisting}

The full proof can be found in the attached file \lstinline!evaluation.bel!.

\paragraph{When is a program a proof?} So far we have just written a
functional program; for it to be a proof it needs to be a total
function, i.e. it must be defined on all inputs and it must be
terminating. We can check that the function is total in \beluga by
writing the following annotation before we start writing the body of
the function:\lstinline!/ total s (tps m t m' d s) /!. This
annotations states that we claim to implement program \lstinline!tps! that is
recursive in \lstinline!s!. Since in the statement we implicitly
quantify over term \lstinline!M! and \lstinline!M'! as well as the
type \lstinline!T! at the outside, we write in the totality
declaration \lstinline!(tps m t m' d s)! indicating that we are
recursively analyzing the 4th argument (three of them are passed
implicitly) passed to \lstinline!tps!. The order in which the
implicite arguments are listed is irrelevant; what is important is
that their number is correct.
The full proof is then written as follows:


\begin{lstlisting}
rec tps: [|-hastype M T] -> [|-step M M'] -> [|-hastype M' T] =
/ total s (tps m t m' d s) /
fn d => fn s => case s of
| [|-e_if_true] =>
  let [|-t_if_then_else D D1 D2] = d in [|-D1]
| [|-e_if_false] =>
  let [|-t_if_then_else D D1 D2] = d in [|-D2]
| [|-e_if_then_else S] =>
  let [|-t_if_then_else D D1 D2] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_if_then_else D' D1 D2]
| [|-e_pred_zero] =>
  let [|-t_pred _ ] = d in  [|-t_zero]
| [|-e_pred_succ _ ] =>
  let [|-t_pred (t_succ D) ] = d in [|-D]
| [|-e_iszero_zero] =>
  let [|-t_iszero _] = d in [|-t_true]
| [|-e_iszero_succ _ ] =>
  let [|-t_iszero _] = d in [|-t_false]
| [|-e_pred S] =>
  let [|-t_pred D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_pred D']
| [|-e_succ S] =>
  let [|-t_succ D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_succ D']
| [|-e_iszero S] =>
  let [|-t_iszero D] = d in
  let [|-D'] = tps [|-D] [|-S] in
  [|-t_iszero D']
;
\end{lstlisting}


\subsection{Uniquenss of Small-step Evaluation: Proving something is impossible}
Next, we consider the proof that evaluation using the small-step rules yields a
unique value. This is an interesting proof because we must argue that values do
not step, i.e. there are not rules that apply. For \lstinline!zero!,
\lstinline!true! and \lstinline!false! this should be easy, since there is no
rule that applies. But how do we argue that \emph{every number} that is a value
does not step? - We prove a contradiction. We show inductively that if $M$ is a
value and $M \Steps M'$ then we can derive falsehood (written as $\bot$).

\begin{theorem}
If $\proofderiv{\S}{M \Steps M'}$ and $\proofderiv{\V}{M \Value}$ then $\bot$.
\end{theorem}
\begin{proof}
By structural induction on the derivation $\proofderiv{\V}{M \Value}$.

\begin{basecase}{$\V = \ianc{}{\tmzero \Value}{}$}
$\proofderiv{\S}{\tmzero \Steps M'}$ \hfill by assumption \\
By inspecting all the existing rules, there exists no $M'$. Therefore, this
assumption is false, and from false we can derive anything; in particular, we
can conclude $\bot$.
\end{basecase}

\begin{stepcase}{$\V = \ianc{\above{\V'}{ N \Value}}{(\tmsucc N) \Value}{}$}
$\proofderiv{\S~}{(\tmsucc N) \Steps M'}$ \hfill by assumption \\
$\proofderiv{\S'}{N \Steps N'}$ \quad and \quad $M' = (\tmsucc N')$ \hfill by inversion using $\ESucc$\\
$\bot$ \hfill by i.h. using $\S'$ and $\V'$
\end{stepcase}

\end{proof}


How do we model in a programming environment $\bot$ (falsehood)? - In a
dependently typed language, we are modelling $\bot$ indirectly. Recall that
there is no way to for example construct an element of the type
\lstinline!step zero zero!.  If we think of the set of elements belonging to the type
\lstinline!step M M'!, then \lstinline!step zero zero! is not in it, but for
example \lstinline!step (pred zero) zero! is; so is
\lstinline!step (succ (pred zero)) (succ zero)!. Generally speaking, if we
define no elements
belonging to a type, then the type is guaranteed to be empty and models false.
In \beluga, we can define types without elements simply by declaring a type.

\begin{lstlisting}
not_possible: type.
\end{lstlisting}

We then can translate the theorem directly into a computation-level type in
\beluga; we have also included the totality declaration, stating that this
function is recursively defined on values, i.e. object of type \lstinline![ |-value M]!.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
?
;
\end{lstlisting}

As before, we introduce the assumption \lstinline!s! for
\lstinline![|-step M M']! and \lstinline!v! for
\lstinline![|-value M]!. Then we case-analyze \lstinline!v!.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
fn s => fn v => case v of
| [ |-v_true]   => ?
| [ |-v_false]  => ?
| [ |-v_z ]     => ?
| [ |-v_s V']   => ?
;
\end{lstlisting}

Let's consider the case \lstinline![|-v_z] : [|-value zero]!. We argued in the
proof by ``By inspecting all the existing rules, there exists no $M'$.'' This
corresponds to case-analyzing \lstinline!s!; however, there are no cases. In
\beluga, we write \lstinline!impossible s in []! for splitting \lstinline!s! in
the empty context. It is effectively a case-expression without branches.

For the step-case, the translation of the proof to a program is more
straightforward: the inversion in the proof is translated to analyzing
\lstinline!s!; the appeal to the induction hypothesis corresponds to making a
recursive call.

\begin{lstlisting}
rec values_dont_step : [ |-step M M'] -> [ |-value M] -> [ |-not_possible] =
/ total v (values_dont_step m m' s v) /
fn s => fn v => case v of
| [ |-v_true]   => impossible s in []
| [ |-v_false]  => impossible s in []
| [ |-v_z ]     => impossible s in []
| [ |-v_s V']   => let [ |-e_succ S'] = s in values_dont_step [ |-S'] [ |-V']
;
\end{lstlisting}

One may wonder whether we can actually ever execute and run this program; the
answer is no, since there is no way to provide a derivation
\lstinline![|-step M M']! and at the same time a proof \lstinline![|-value M]!.


We are now ready to prove that evaluation yields a unique result given the
small-step semantics. This will illustrate how we can use the lemma \lstinline!values_dont_step!.We only show two cases, but the whole program is
implemented in file \lstinline!evaluation.bel!.

\begin{lstlisting}
datatype equal: term -> term -> type =
| ref: equal T T
;


rec unique : [|-step M M1] -> [|-step M M2] -> [ |-equal M1 M2] =
/ total s (unique m m1 m2 s)/
fn s1 => fn s2 => case s1 of
| [ |-e_if_true]  =>
  (case s2 of
   | [|-e_if_true]  =>  [ |-ref]
   | [|-e_if_then_else D]      => impossible values_dont_step [|-D] [|-v_true] in []
)
| [ |-e_if_false] =>
  (case s2 of
   | [|-e_if_false] =>  [ |-ref]
   | [|-e_if_then_else D]      => impossible values_dont_step [|-D] [|-v_false] in []
)

| [ |-e_if_then_else D] =>
  (case s2 of
  | [|-e_if_then_else E] =>
    let [ |-ref] = unique [|-D] [|-E] in  [ |-ref]
  | [|-e_if_true] => impossible values_dont_step [|-D] [|-v_true] in []
  | [|-e_if_false] => impossible values_dont_step [|-D] [|-v_false] in [])

| [ |-e_succ D]        => ?
| [ |-e_pred_zero]     => ?
| [ |-e_pred_succ V]   => ?
| [ |-e_pred D]        => ?
| [ |-e_iszero_zero]   => ?
| [ |-e_iszero_succ V] => ?
| [ |-e_iszero D]      => ?
;
\end{lstlisting}

Let us consider the case where \lstinline!s1! is a derivation ending in
\lstinline![|-e_if_true]!, i.e. \lstinline!s1! stands for a derivation of 
\lstinline![|-step (if_then_else true N1 N2) N1]!. At this point we know that \lstinline!s2! stands
for a derivation \lstinline![|-step (if_then_else true N1 N2) M2]!. Splitting
\lstinline!s2! into cases gives us two sub-cases:
\begin{enumerate}
\item We have used the rule
\lstinline!e_if_true!. In this case, we learn that
\lstinline!M2 = N1!. Clearly, we can conclude \lstinline![|-equal N1 N1]! by
using \lstinline![ |-ref]! as a witness.

\item We have used the rule \lstinline!e_if_then_else!. In this case, we have a
  sub-derivation \lstinline!D: |-step true N'! and \lstinline!M2 = (if_then_else N' N1 N2)!.
We now use the lemma \lstinline!values_dont_step! passing \lstinline![|-D]! (a
proof for \lstinline![|-step true N']!) and \lstinline![|-v_true]! (a witness
for \lstinline![|-value true]!.
We therefore obtain an object of type \lstinline![|-not_possible]!; but no
elements of this type exist.
\end{enumerate}

Next, consider the case where \lstinline!s1! describes the derivation
\lstinline![|-step (if_then_else N N1 N2) (if_then_else N' N1 N2)]! and we pattern match on
\lstinline![|-e_if_then_else D]! where \lstinline!D! stands for the sub-derivation
\lstinline![|-step N N']!. At this point we know that \lstinline!s2! stands
for a derivation \lstinline![|-step (if_then_else N N1 N2) M2]!. Splitting
\lstinline!s2! into cases gives us three sub-cases:

\begin{enumerate}
\item We have used the rule \lstinline!e_if_true!. As a consequence
  \lstinline!N = true! and \lstinline!M2 = N1!. Moreover,
  \lstinline!D! now stands for the sub-derivation \lstinline![|-step true N']!.
  Using again the lemma \lstinline!values_dont_step!, we show that this is impossible.
\item We have used the rule \lstinline!e_if_false!. This case is similar to
  the one for \lstinline!e_if_true!.
\item We have used the rule \lstinline!e_if_then_else! and we pattern match on
\lstinline![|-e_if_then_else E]! where \lstinline!E! stands for a sub-derivation
\lstinline![|-step N N'']! and \lstinline!M2 = (if_then_else N' N1 N2)!.
We now call recursively \lstinline!unique [|-D] [|-E]! giving us a proof
\lstinline![|-equal N N']!. By inversion using \lstinline!ref!, we learn that
\lstinline!N = N'!. We still need to provide a witness for
\lstinline![|-equal (if_then_else N N1 N2) (if_then_else N N1 N2)]!. This is easily
accomplished by \lstinline![|-ref]!. \\[0.5em]
It might look like we should be able to simply make a recursive call. This is
however a fallacy, since the type is incorrect. Recall that \lstinline!ref!
takes in an implicit argument for the term we are actually comparing; therefore
in the first occurrence \lstinline![|-ref]! stands actually for
\lstinline![|-ref <<N>>]!, while in the second occurrence it % \lstinline![|-ref]!
stands for \lstinline![|-ref <<(if_then_else N N1 N2)>>]!.
\end{enumerate}


\subsection{Termination of Well-typed Terms}
Our goal is to prove that the evaluation of well-typed terms halts. In
fact we already proved progress, i.e. evaluation cannot get stuck on
well-typed terms, i.e. either a well-typed term yields a value or we
can take another step. In this section we prove that we can always
evaluate a well-typed term to a final value.

\begin{theorem}
If $\proofderivc{\D}{}{M : T}$ then $M \Halts$, i.e.~there exists a value $V$ s.t. $M
\MSteps V$.
\end{theorem}

We recap our definition of multi-step relations that was the
reflexive, transitive closure over the single step relation.

\[
\begin{array}{c@{\qquad}c@{\qquad}c}
\infer[\MRef]{M \MSteps M}{} &
\infer[\MTr]{M \MSteps N}{M \MSteps K & K \MSteps N} &
\infer[\MStep]{M \MSteps N}{M \Steps N}
\end{array}
\]

Evaluation of a term $M$ may clearly not yield a value in one step; in fact we may need to chain multiple steps together.
In the proof for showing that well-typed terms terminate, we will see the need for lemmas that justify bigger steps when we evaluate a term.

\begin{lemma}[Multi Step Lemmas]~
  \begin{enumerate}
  \item If $M \MSteps M'$ then $(\tmpred M) \MSteps (\tmpred M')$.
  \item If $M \MSteps M'$ then $(\tmsucc M) \MSteps (\tmsucc M')$.
  \item If $M \MSteps M'$ then $(\tmiszero M) \MSteps (\tmiszero M')$.
  \item If $M \MSteps M'$ then $(\tmif M {M_1} {M_2}) \MSteps (\tmif {M'} {M_1} {M_2})$.
  \end{enumerate}
\end{lemma}
\begin{proof}
By structural induction  on $M \MSteps M'$.
\end{proof}

Moreover, we lift type preservation to multi-step relations.

\begin{lemma}[Type preservation for multi-step relation]
If $\vdash M : T$ and $M \MSteps M'$ then $\vdash M':T$.
\end{lemma}
\begin{proof}
By structural induction on $M \MSteps M'$.
\end{proof}

Finally, we are ready to consider the proof that evaluation of well-typed terms
terminates. We first define $M \Halts$ as follows:

\[
\begin{array}{c}
\infer{M \Halts}{M \MSteps V & V \Value }
\end{array}
\]



\begin{proof}
By structural induction on $\proofderivc{\D}{}{M : T}$. We show a few
representative cases.

\begin{case}{$\D = \ianc{}{\vdash \tmzero :\Nat}{\TZero}$}
$\tmzero \Value$ \hfill by $\VZero$ rule \\
$\tmzero \MSteps \tmzero$ \hfill by $\MRef$\\
$\tmzero \Value$ \hfill by definition $\VZero$\\
$\tmzero \Halts$ \hfill by definition of $\Halts$
\end{case}

\begin{case}{$\D = \ianc{\above{\D'}{\vdash N : \Nat}}{\vdash (\tmpred N) : \Nat}{\TPred}$}
$N \Halts$, i.e. $\exists V.$ s.t.$~\V':V\Value$ ~~and~~ $\S':N \MSteps V$ \hfill by i.h. $\D'$\\[1em]
%
\fbox{To Prove: ~~~$M\Halts$, i.e.$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$}\\[1em]
%
\begin{subcase}{$\V' = \ianc{}{\tmzero \Value}{\VZero}$ \quad and \quad $V = \tmzero$}
$\S': N \MSteps \tmzero$ \hfill restating assumption $\S'$\\
$\S_0: (\tmpred N) \MSteps (\tmpred \tmzero)$ \hfill by lemma mstep-pred \\
$\S_1: (\tmpred \tmzero) \MSteps \tmzero$ \hfill by $\MStep$ using $\EPredZ$\\
$\S~: (\tmpred N) \MSteps \tmzero$ \hfill by $\MTr$ using $\S_0$ and $\S_1$\\
$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$ \hfill by choosing
$W = \tmzero$\\
$(\tmpred N)\Halts$ \hfill by definition of $\Halts$
\end{subcase}

\begin{subcase}{$\V' = \ianc{\above{\W}{V'\Value}}{(\tmsucc V') \Value}{\VSuc}$ \quad and \quad $V = \tmsucc V'$}
$\S': N \MSteps (\tmsucc V')$ \hfill restating assumption $\S'$\\
$\S_0: (\tmpred N) \MSteps (\tmpred (\tmsucc V'))$ \hfill by lemma mstep-pred \\
$\S_1: (\tmpred (\tmsucc V')) \MSteps V'$ \hfill by $\MStep$ using $\EPredSucc$ and $\W$\\
$\S~: (\tmpred N) \MSteps V'$ \hfill by $\MTr$ using $\S_0$ and $\S_1$\\
$\exists W$.s.t.$W \Value$~~~and~~~$\S:~(\tmpred N) \MSteps W$ \hfill by choosing
$W = V'$\\
$(\tmpred N)\Halts$ \hfill by definition of $\Halts$
\end{subcase}

\begin{subcase}{$\V' = \ianc{}{\tmtrue \Value}{\VTrue}$ \quad and \quad  $V = \tmtrue$}
$\S': N \MSteps \tmtrue$ \hfill restating assumption $\S'$\\
$\F~:~ \vdash \tmtrue : \Nat$ \hfill by type preservation for multi-step relations using $\D'$\\
$~~~ \bot$ \hfill
\end{subcase}

\begin{subcase}{$\V' = \ianc{}{\tmfalse \Value}{\VFalse}$ \quad and \quad $V = \tmfalse$}
Similar to the case where $V = \tmtrue$.
\end{subcase}
\end{case}

\end{proof}


We now discuss how to mechanize this proof as a program. As a first step, we
must encode the statement of the theorem as a type.

\begin{lstlisting}
datatype halts: term -> type =
| result: multi_step M V -> value V
       -> halts M;


rec terminate : [|- hastype M T] -> [ |- halts M] =
/ total d (terminate m t d)/
fn d => ? ;

\end{lstlisting}

Again we encode the case analysis in the proof as a case analysis in the program
splitting on the assumption \lstinline!d!. We show below the cases we discussed
in detail above, however the full proof is implemented in the file
\lstinline!evaluation.bel!.

For the case, where we have \lstinline!d:[|- hastype z nat]! by
\lstinline![|-t_zero]!, we return \lstinline![|-result ms_ref (v_num v_z)]! that
stands for a proof \lstinline![|- halts z]!. For the case where we have
\lstinline!d:[|-hastype (pred N) nat]! by \lstinline![|-t_pred D]! and
\lstinline!D! stands for a sub-derivation \lstinline![|- hastype N nat]!. By the
induction hypothesis on \lstinline!D! (i.e. modelled via the recursive call), we
obtain a proof that \lstinline![|- halts N]!.  By inversion, we know that this
proof has the following shape: \lstinline![|-result MS W]! where \lstinline!MS!
stands for \lstinline![|-multistep N R]! and \lstinline!W!
stands for a proof \lstinline![|-value R]!. We now case-analyze
\lstinline![|-value R]!. If \lstinline!R=z! and we have a derivation
\lstinline![|-v_num v_z]!, we call our lemma \lstinline!mstep_pred! with
\lstinline!MS! to obtain a derivation \lstinline!MS'! for
\lstinline![|-multi_step (pred N) (pred z)]!. What remains is to build a proof
for \lstinline![|-halts (pred N)]!. First, we build a proof \lstinline![|-v_num vz]!
that \lstinline![|-value z]!. Second, we build a proof for
\lstinline![|-multi_step (pred N) z]! using transitivity together with
\lstinline!MS'! and the derivation \lstinline![|-ms_step e_pred_zero]! for
\lstinline![|-multi_step (pred z) z]!.


\begin{lstlisting}
rec terminate : [|-hastype M T] -> [ |-halts M] =
/ total d (terminate m t d)/
fn d => case d of
| [ |-t_true]  => ?
| [ |-t_false] => ?
| [ |-t_if_then_else D D1 D2] => ?
| [ |-t_zero] => [ |-result ms_ref (v_num v_z)]
| [ |-t_succ D] => ?
| [ |-t_pred D] => (case terminate [ |-D ] of
   | [ |-result MS (v_num v_z)] =>
     let [ |-MS']         = mstep_pred [ |-MS] in
       [ |-result (ms_tr MS' (ms_step e_pred_zero)) (v_num v_z)]
   | [ |-result MS (v_num (v_s V))] =>
     let [ |-MS']         = mstep_pred [ |-MS] in
       [ |-result (ms_tr MS' (ms_step (e_pred_succ V))) (v_num V)]
   | [ |-result MS v_true] => impossible multi_tps [|-D] [|-MS] in []
   | [|-result MS v_false] => impossible multi_tps [|-D] [|-MS] in []
 )
| [|-t_iszero D] => ?
;
\end{lstlisting}

% \section{Exercise 3.5.17}
\subsection{Relating small-step and big-step semantics}


\paragraph{Definition of the big-step semantics}

% Almost taken from TAPL:
Two styles of operational semantics are in common use. The one used so far and
most commonly used in \cite{TAPL} is called the {\em small-step} style, because the definition of the
evaluation relation shows how individual steps of computation are used to
rewrite a term, bit by bit, until it eventually becomes a value. On top of this,
we define a multi-step evaluation relation that allows us to talk about terms
evaluating (in many steps) to values. An alternative style, called
{\em big-step} semantics (or sometimes {\em natural} semantics), directly
formulates the notion of ``this term evaluates to that final value'', written
$t \Downarrow v$. The big-step evaluation rules for our language of boolean and
arithmetic expressions can be described as follows:

% If someone can do something nicer than that:
\[
\begin{array}{c}
\multicolumn{1}{l}{\fbox{$t \Downarrow v$}: \mbox{Term $t$ evaluates to value $v$}}\\[1em]
  \infer[\BValue]{v \Downarrow v}{v \Value} \qquad
  \infer[\BSucc]{\tmsucc t_1 \Downarrow \tmsucc nv_1}{t_1 \Downarrow nv_1 & nv_1 \NumValue} \\[0.5em]
  \infer[\BPredZero]{\tmpred t_1 \Downarrow \tmzero}{t_1 \Downarrow \tmzero} \qquad
  \infer[\BPredSucc]{\tmpred t_1 \Downarrow nv_1}{t_1 \Downarrow \tmsucc nv_1}
\\[0.5em]
  \infer[\BIszeroZero]{\tmiszero t_1 \Downarrow \tmtrue}{t_1 \Downarrow \tmzero} \qquad
  \infer[\BIszeroSucc]{\tmiszero t_1 \Downarrow \tmfalse}{t_1 \Downarrow \tmsucc nv_1} 
\\[0.5em]
  \infer[\BIfTrue]{\tmif {t_1}{t_2}{t_3} \Downarrow v_2}{t_1 \Downarrow true & t_2 \Downarrow v_2 & v_2 \Value} \qquad
  \infer[\BIfFalse]{\tmif {t_1}{t_2}{t_3} \Downarrow v_3}{t_1 \Downarrow false & t_3 \Downarrow v_3 & v_3 \Value} \\

\end{array}
\]

Following the previous principle of encode judgments such as $t \Downarrow v$
using predicates (type families), we define in \beluga the relation
\lstinline!bigstep! between two terms. The fact that the result is always a
value is enforced and checked in each rule - this is unnecessary, since we can
in fact prove that the result of evaluating a term always yields a value
(i.e. value soundness property)\todo{Remove extra checks and state value
  soundness. -bp}. 

\begin{lstlisting}
LF bigstep : term -> term -> type =
| b_value       : value V 
               -> bigstep V V
| b_switchtrue  : bigstep M1 true -> bigstep M2 V2 -> value V2
               -> bigstep (switch M1 M2 M3) V2
| b_switchfalse : bigstep M1 false -> bigstep M3 V3 -> value V3
               -> bigstep (switch M1 M2 M3) V3
| b_succ        : bigstep M1 NV1 -> num_value NV1
               -> bigstep (succ M1) (succ NV1)
| b_predzero    : bigstep M1 zero
               -> bigstep (pred M1) zero
| b_predsucc    : bigstep M1 (succ NV1) -> num_value NV1
               -> bigstep (pred M1) NV1
| b_iszerozero : bigstep M1 zero
              -> bigstep (iszero M1) true
| b_iszerosucc : bigstep M1 (succ NV1) -> num_value NV1
              -> bigstep (iszero M1) false
;
\end{lstlisting}

We now prove that the small-step and big-step semantics for this language
coincide, {\em i.e.} $t \rightarrow^* v$ if and only if $t \Downarrow v$, for
any value $v$.

We will prove the two directions of the ``if and only if'' separately.

\paragraph{Part1: If $t \Downarrow v$ then $t \rightarrow^* v$}
This part of the proof is exactly the one described in TAPL. We firstly need a
little lemma that prooves that $\longrightarrow^*$ passes to the context:
%                                                  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
%                                                  this is not english, right?

\begin{lemma}[A.6]
  If $t_1 \longrightarrow^* t_1'$ then
  \begin{enumerate}
    \item $\tmsucc t_1 \longrightarrow^* \tmsucc t_1'$
    \item $\tmpred t_1 \longrightarrow^* \tmpred t_1'$
    \item $\tmiszero t_1 \longrightarrow^* \tmiszero t_1'$
    \item $\tmif {t_1} {t_2} {t_3} \longrightarrow^* \tmif {t_1'} {t_2} {t_3}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  We'll only proove the fourth one, by induction on the proof
  $t_1 \longrightarrow^* t_1'$. By definition of $\longrightarrow^*$ as the
  reflexive transitive closure or $\longrightarrow$, we have three cases:
  \begin{enumerate}
    \item the case where $t_1 \longrightarrow^* t_1' = t_1 \longrightarrow t_1'$
      is easy since the \EIf rule gives us $\tmif{t_1}{t_2}{t_3}
      \longrightarrow \tmif{t_1'}{t_2}{t_3}$ and thus $\tmif{t_1}{t_2}{t_3}
      \longrightarrow^* \tmif{t_1'}{t_2}{t_3}$.
      
    \item the case where $t_1 \longrightarrow^* t_1$ is the reflexivity of
      $\longrightarrow^*$ ; the same reflexivity gives us:
      $\tmif{t_1}{t_2}{t_3} \longrightarrow^* \tmif{t_1}{t_2}{t_3}$.
    
    \item in the case $t_1 \longrightarrow^* t_1'' \longrightarrow^* t_1'$,
      the $\longrightarrow^*$ proofs are smaller so the lemma can be applied on
      them, giving us $\tmif{t_1}{t_2}{t_3} \longrightarrow^*
      \tmif{t_1''}{t_2}{t_3} \longrightarrow^* \tmif{t_1'}{t_2}{t_3}$, which,
      by transitivity implies what we want.
  \end{enumerate}
  The proof is the same for other constructors $\tmsucc$, $\tmpred$ and
  $\tmiszero$.
\end{proof}

The \beluga proof can seem really straightforward, but infact there's a little
problem: when we say ``if $t_1 \longrightarrow^* t_1'$ then
$\tmif{t_1}{t_2}{t_3} \longrightarrow^* \tmif{t_1'}{t_2}{t_3}$, we explain that
we are able to produce a proof that $\tmif{t_1}{t_2}{t_3} \longrightarrow^*
\tmif{t_1'}{t_2}{t_3}$ if we have a proof that $t_1 \longrightarrow^* t_1'$. By
doing so, we implicitely quantify over the terms $t_2$ and $t_3$.

In \beluga, we will have to write this quantification explicitely. Have a look:
%TODO: need way more explainations! (mlam)

\begin{lstlisting}
rec lemma_a6_switch : [|- multistep T1 T1'] -> {T2: [|- term]} {T3: [|- term]} [|- multistep (switch T1 T2 T3) (switch T1' T2 T3)] =
/ total m (lemma_a6_switch _ _ m _ _) /
fn m => mlam T2 => mlam T3 => case m of 
| [|- ms_step S] => [|- ms_step (e_switch S)]
| [|- ms_reflexivity] => [|- ms_reflexivity]
| [|- ms_transitivity S1 S2] =>
   let [|- S1'] = lemma_a6_switch [|- S1] [|- T2] [|- T3] in
   let [|- S2'] = lemma_a6_switch [|- S2] [|- T2] [|- T3] in
   [|- ms_transitivity S1' S2']
;
\end{lstlisting}

%TODO: more explanations (mlam)

The other lemmas do not have to quantify over any terms and are thus
straightforward to write.

Let's now write the actual proof:
\begin{proposition}[A7]
  If $t \Downarrow v$ then $t \longrightarrow^* v.$
  \begin{lstlisting}
    rec proposition_a7 : [|- bigstep T1 T2] -> [|- multistep T1 T2] =
    / total b (proposition_a7 _ _ b) /
    fn b =>
  \end{lstlisting}
\end{proposition}

\begin{proof}
  By induction on the proof $t \Downarrow v$:
  \begin{itemize}
  \item Case $\infer{v \Downarrow v}{}\ \BValue$. By reflexivity of $\rightarrow^*$,
    $v \longrightarrow^* v$.
  \item Case $\infera{\BPredZero}{\tmpred{t_1} \Downarrow \tmzero}
    {t_1 \Downarrow \tmzero}$. The proof in premice is smaller, and the
    proposition applies and gives us one proof: $t_1 \longrightarrow^* \tmzero$.
    We then use it with the lemma A6: $\tmpred{t_1} \longrightarrow^*
    \tmpred{\tmzero} \longrightarrow \tmzero$. And we can conclude thanks to
    transitivity.
  \item Case $\inferaaa{\BIfTrue}{\tmif{t_1}{t_2}{t_3}\Downarrow v_2}
    {t_1 \Downarrow \tmtrue}{t_2 \Downarrow v_2}{v_2 \Value}$. The proofs in the
    premices are smaller than this one, so the proposition applies and gives us
    two proofs: $t_1 \longrightarrow^* \tmtrue$ and $t_2 \longrightarrow^* v_2$.
    Using the lemma A6 and the $\EIfTrue$ rule, we have:
    $$\tmif{t_1}{t_2}{t_3} \longrightarrow^* \tmif{\tmtrue}{t_2}{t_3}
    \longrightarrow t_2 \longrightarrow^* v_2$$
    And we can conclude thanks to the transitivity.
  \item[\vdots]
  \end{itemize}

  \begin{lstlisting}
    case b of 

    | [|- b_value _] => [|- m_ref]

    | [|- b_predzero B1] =>
    let [|- M1] = proposition_a7 [|- B1] in
    let [|- M1'] = lemma_a6_pred [|- M1] in
    [|- m_tr M1' (m_step e_predzero)]

    | [|- b_switchtrue B1 B2 _] : [|- bigstep (switch T1 T2 T3) V] =>
    let [|- M1] = proposition_a7 [|- B1] in
    let [|- M1s] = lemma_a6_switch [|- M1] [|- T2] [|- T3] in
    let [|- M2] = proposition_a7 [|- B2] in
    [|- m_tr (m_tr M1s (m_step e_switchtrue)) M2]

    ..
  \end{lstlisting}
\end{proof}

\paragram{If $t \longrightarrow^* v$ then $t \Downarrow v$ }

For this direction, we will see two proofs. The first one will be a simple proof
easy to write in \beluga. The second one will be the proof describe by the TAPL.

\paragraph{A simple proof}

Let's first proove something weaker, but that can easely imply what we want to
proove:

\begin{proposition}[A9-aux-step]\label{prop_a9_aux_step}
  If $t_1 \longrightarrow t_2 \Downarrow v$ (with $v$ a value),
  then $t_1 \Downarrow v$.
\end{proposition}

Indeed, if we have this property, we can easely obtain:

\begin{proposition}[A9-aux]\label{prop_a9_aux}
  If $t_1 \longrightarrow^* t_2 \Downarrow v$ then $t_1 \Downarrow v$.
  \begin{lstlisting}
    rec proposition_a9_aux : [|- multistep M1 M2] -> [|- bigstep M2 V] -> [|- value V] -> [|- bigstep M1 V] =
    / total m (proposition_a9_aux _ _ _ m _ _) /
    fn m => fn b => fn v => 
  \end{lstlisting}
\end{proposition}
\begin{proof}
  Let's consider the three possibilities for $\rightarrow^*$:
  \begin{itemize}
  \item Case $t_1 \longrightarrow t_2 \Downarrow v$: We just apply the
    proposition \ref{prop_a9_aux_step} and get $t_1 \Downarrow v$.
  \item Case $t_1 \longrightarrow^* t_1 \Downarrow v$: We have
    $t_1 \Downarrow v$.
  \item Case $t_1 \longrightarrow^* t_{12} \longrightarrow^* t_2 \Downarrow v$:
    We apply this proposition recursively and get $t_1 \longrightarrow^* t_{12}
    \Downarrow v$ then $t_1 \Downarrow v$.
  \end{itemize}
  \begin{lstlisting}
    case m of
    | [|- m_step E]   => proposition_a9_aux_step [|- E] b v
    | [|- m_ref]      => b
    | [|- m_tr M1 M2] =>
    let [|- B2] = proposition_a9_aux [|- M2] b v in
    proposition_a9_aux [|- M1] [|- B2] v
  \end{lstlisting}
\end{proof}

And then:

\begin{proposition}[A9]
  If $t \longrightarrow^* v$ then $t \Downarrow v$.
  \begin{lstlisting}
    rec proposition_a9 : [|- multistep T V] -> [|- value V] -> [|- bigstep T V] =
    / total m (proposition_a9 _ _ m _) /
    fn m => fn v =>
  \end{lstlisting}
\end{proposition}
\begin{proof}
  We apply the proposition \ref{prop_a9_aux} for $t \longrightarrow^* v
  \Downarrow v$.
  \begin{lstlisting}
    let [|- V] = v in
    proposition_a9_aux m [|- bs_value V] v
  \end{lstlisting}
\end{proof}

%TODO: bind this proof to his proposition in LaTeX?
%  If t1 → t2 ↓ v then t1 ↓ v.
\begin{proof}[Proof of proposition~\ref{prop_a9_aux_step}]
  In $t \longrightarrow t' \Downarrow v$, let's consider the different cases for
  $\rightarrow$:
  \begin{itemize}

  \item Case $\tmif{\tmtrue}{t_2}{t_3} \longrightarrow t_2 \Downarrow v$:\\
    We can directly construct the following:
    \[ \inferaaa{\BIfTrue}{\tmif{\tmtrue}{t_2}{t_3} \Downarrow v}{\infer{\tmtrue \Downarrow \tmtrue}{}}{t_2 \Downarrow v}{v \Value} \]
  \item[\vdots] {\em same for other ``terminal'' cases} %TODO: reword

  \item Case $\tmif{t_1}{t_2}{t_3} \longrightarrow \tmif{t_1'}{t_2}{t_3}
    \Downarrow v$:\\
    Let's consider the different cases for $\Downarrow$:
    \begin{itemize}
    \item Case $\tmif{t_1}{t_2}{t_3} \longrightarrow \tmif{\tmtrue}{t_2}{t_3}
      \Downarrow v$:\\
      We know that $t_1 \longrightarrow \tmtrue$ and that $t_2 \Downarrow v$.
      Thanks to proposition~\ref{prop_a9_aux_step}, we can build a proof of
      $t_1 \Downarrow \tmtrue$ and we can then construct the following proof:
      \[ \inferaaa{\BIfTrue}{\tmif{t_1}{t_2}{t_3} \Downarrow v}{t_1 \Downarrow \tmtrue}{t_2 \Downarrow v}{v \Value} \]
    \item {\em same for \tmfalse}
    \end{itemize}
  \item[\vdots] {\em same for other ``context'' cases} %TODO: reword

  \end{itemize}
  \begin{lstlisting}
    %TODO: write proof
  \end{lstlisting}
\end{proof}

\subsubsection{A proof following the TAPL}

\section{How to Trust Proof Environments}
How can we trust systems such as \beluga? - This leads to a larger question: how do we trust programming and proof environments? how do we trust theorem provers or other reasoning tools? - Many tools do not provide any witness that would explain how they have arrived at the given result and could be checked independenlty.

In \beluga, a given program is elaborated into a core language and all elaborated programs are type-checked in a small core kernel language. We do not trust that elaboration is correct - we verify after the fact. In fact this kernel language and the source code that implements type checking for it is so small that it can be easily verified by directly looking at the source code and the theoretical foundations describing \beluga. Verifying that all recursive calls are well-founded can also be fairly easily verified in this manner; coverage is however more complex.

The ultimate goal is to translate \beluga programs to a primitive recursive core language that would not only guarantee that the given program is well-typed but also that it is total. Again we would not trust the elaboration, but verify after the fact by type-checking our primitive recursive core and proving the elaboration sound.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
