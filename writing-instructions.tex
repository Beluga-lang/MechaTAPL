\documentclass[12pt]{article}
\input{prelude}


\begin{document}
This document describes how to use macros defined in \verb#prelude.tex# and how to define new ones. It also mentions conventions used in the tutorial, to keep it consistent. And, you know, other stuff.

\section{General}
\begin{itemize}
\item Follow the ``Notational Conventions'' from Appendix B of TAPL; use the same nomenclature as in the book.
\item Use \verb#\beluga# for \beluga, same with other names defined in ``Names of languages'' section of the prelude.
\item All macros, packages used etc should be in \verb#prelude.tex#, don't add that stuff to your chapter file.
\item When creating new macros, stick to the naming conventions and style that we have; put them in the correct place in \verb#prelude.tex# file.
\item It probably makes sense to browse through the \verb#prelude.tex#, there are some useful shortcuts there, not all of them described here.
\end{itemize}

\section{Syntax, inference rules, proofs}
\begin{itemize}
\item Macros for inference rules' names are created using \verb#\ruleName{rule-name}#, e.g. \ruleName{rule-name}; technically you can use that directly but creating macros for the new ones will make the code cleaner.
\item Do not use \verb#\textsf, \mathsf# etc directly in the text, add macros.
\item Avoid \verb#\;# in the text -- what you probably want is to define a command that takes some arguments instead. For instance $\tmhastype {(\tmlam x {T_1} M)} (\tmarr {T_1} T_2)$ is generated by \verb#$\tmhastype {(\tmlam x {T_1} M)} (\tmarr T_1 T_2)$#, if the macros don't take arguments the code is\\
\verb#$\tmhastype\;(\tmlam\;x{:}T_1.M)\;(\tmarr\;T_1\;T_2)$#.
\item To define a BNF grammar for syntax:
\[
\begin{array}{ll@{\bnfas}l}
\mbox{Terms} & M, N & x \bnfalt \lam x{:}T.M \bnfalt M \app N
\end{array}
\]
\begin{verbatim}
\[
\begin{array}{ll@{\bnfas}l}
\mbox{Terms} & M, N & x \bnfalt \lam x{:}T.M \bnfalt M \app N
\end{array}
\]
\end{verbatim}
In particular, use \verb#\bnfas# and \verb#\bnfalt# rather than \verb#::=# \verb#\mid# directly.
\item When defining inference rules, the following should be a good starting point:
\begin{verbatim}
\[
\begin{array}{l@{\quad}l}
\multicolumn{2}{l}
  {\fbox{$e \Value$}: \mbox{Expression $e$ is a value}}\\[1em]
\infer[\VZero]{\tmzero \Value}{} &
\infer[\VSuc]{(\tmsucc t) \Value}{t \Value} \\[1em]
\infer[\VTrue]{\tmtrue \Value}{} &
\infer[\VFalse]{\tmfalse \Value}{}
\end{array}
\]
\end{verbatim}
The resulting array is:
\[
\begin{array}{l@{\quad}l}
\multicolumn{2}{l}{\fbox{$e \Value$}: \mbox{Expression $e$ is a value}}\\[1em]
\infer[\VZero]{\tmzero \Value}{} &
\infer[\VSuc]{(\tmsucc t) \Value}{t \Value} \\[1em]
\infer[\VTrue]{\tmtrue \Value}{} &
\infer[\VFalse]{\tmfalse \Value}{}
\end{array}
\]
\item We use \verb#\infer# (also \verb#\infer*# and \verb#\deduce#) from proof package for inference rules \url{http://www.logicmatters.net/resources/ndexamples/proofsty.html}. However, because we want to sometimes have nicer alignment, the commands \verb#\infera \inferaa \inferaaa# exist (for 1, 2 and 3 premise-rules). It seems to be enough to use them as the outermost commands. Compare
\[
\D = \inferaa
            {\TApp}
            { \Gamma \vdash \tmhastype {(\tmapp M N)} S}
            { \deduce[\vspace{2pt}]{\Gamma \vdash \tmhastype M {(\tmarr T S)}}{\D_1}}
            { \deduce[\vspace{2pt}]{\Gamma \vdash \tmhastype N T}{\D_2}}\]
with
\[\D = \infer
            [\TApp]
            { \Gamma \vdash \tmhastype {(\tmapp M N)} S}
            { \deduce[\vspace{2pt}]{\Gamma \vdash \tmhastype M {(\tmarr T S)}}{\D_1} &
              \deduce[\vspace{2pt}]{\Gamma \vdash \tmhastype N T}{\D_2}}\]
The former is generated using
\begin{verbatim}
$\D =
\inferaa{\TApp}
  {\Gamma \vdash \tmhastype {(\tmapp M N)} S}
  {\deduce[\vspace{2pt}]
     {\Gamma \vdash \tmhastype M {(\tmarr T S)}}{\D_1}}
  {\deduce[\vspace{2pt}]
     {\Gamma \vdash \tmhastype N T}{\D_2}}$
\end{verbatim}

\item When formulating a theorem, it's good to name the derivations. I use \\
\verb#$\proofderiv{name-in-mathcal}{judgment}$#, e.g. $\proofderiv{\D}{M \Steps M'}$. There's also a variant with built-in $\vdash$:\\
\verb#$\proofderivc{\D}{\Gamma}{M : T}$# $\proofderivc{\D}{\Gamma}{M : T}$\\
I'd suggest using the same when describing proofs.
\item There's an environment for writing cases in proofs (actually, there's more than one). It's not fully satisfactory, but at least it a way of keeping things looking consistent.\\
\verb#\begin{case}{you can put the case here}actual proof\end{case}#
\begin{case}{$\D = \infera{u} {\Gamma \vdash \tmhastype x T}
    {x, u : \tmhastype x T \in \Gamma}$}
Here goes the actual proof
\end{case}
There are examples of this environment in use in chapters 2 and 3.
\end{itemize}

\section{Beluga code}
\begin{itemize}
\item Use \verb#\lstinline![ |- t_lam \x . x]!# to get \lstinline![ |- t_lam \x . x]!
\item Use \verb#\begin{lslisting} .. \end{lslisting}# to show bigger fragments of \beluga code
\item Both of the above commands are like verbatim mode, so whitespace is (..should be, anyway) preserved.
\item Because I'm lazy, \verb#\bel{beluga code}# can be used instead of \\
\verb#\lstinline!beluga code!#.
\item Some keywords in \beluga code are automatically highlighted/coloured etc -- if you feel there's something missing, ``Contextual ML'' section of \verb#prelude.tex# contains all the settings. It will get a proper cleanup at some point, right now some more advanced settings are voodoo (to me anyway).
\item \emph{FIXME} describe how to do literate programming/code extraction from the LaTeX source
\end{itemize}

\section{Exercises}
\begin{itemize}
\item \emph{FIXME} describe how to give exercises / solutions / additional explanations
\end{itemize}

\end{document}
